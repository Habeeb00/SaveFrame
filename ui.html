<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frame Presets</title>
    <style>
      :root {
        /* Light Mode Variables */
        --primary-color: #0d99ff;
        --secondary-color: #888888;
        --bg-color: #ffffff;
        --text-color: #333333;
        --border-color: #e0e0e0;
        --active-color: #f5f5f5;
        --hover-color: #f0f0f0;
        --accent-color: #0d99ff;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --figma-bg: #f5f5f5;
        --figma-text: #333333;
        --figma-secondary: #7f7f7f;
        --figma-border: #e5e5e5;
        --figma-hover: #e8e8e8;
        --figma-blue: #18a0fb;
        --figma-blue-hover: #0d8de3;
        --tooltip-delay: 600ms;
        --error-color: #ff3b30;
        --button-color: #2c2c2e;
        --collection-header-bg: #2c2c2e;
      }

      :root {
        /* Common transition variables */
        --transition-speed: 0.3s;
        --transition-function: ease;
      }

      [data-theme="dark"] {
        /* Dark Mode Variables */
        --primary-color: #0a84ff;
        --secondary-color: #8e8e93;
        --text-primary: #ffffff;
        --text-secondary: #aeaeb2;
        --bg-color: #1c1c1e;
        --sidebar-bg: #2c2c2e;
        --border-color: #38383a;
        --hover-color: #3a3a3c;
        --active-color: #2c4a67;
        --danger-color: #ff4530;
        --shadow-color: rgba(0, 0, 0, 0.3);
        --button-color: #2c2c2e;
        --collection-header-bg: #2c2c2e;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        font-size: 10px;
        transition-property: background-color, border-color, color, opacity,
          transform, max-height;
        transition-duration: var(--transition-speed);
        transition-timing-function: var(--transition-function);
      }

      body {
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        margin: 0;
        padding: 0;
        font-size: 12px;
        color: var(--figma-text);
        background-color: var(--figma-bg);
        overflow-y: auto;
        overflow-x: hidden;
        overscroll-behavior: none;
      }

      /* Tooltip styles */
      [data-tooltip] {
        position: relative;
      }

      [data-tooltip]::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background-color: #333;
        color: white;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        transition-delay: 0ms;
        pointer-events: none;
        z-index: 1000;
      }

      [data-tooltip]:hover::after {
        opacity: 1;
        visibility: visible;
        transition-delay: var(--tooltip-delay);
      }

      /* Stylish scrollbar */
      ::-webkit-scrollbar {
        width: 4px;
        height: 4px;
      }

      ::-webkit-scrollbar-track {
        background: transparent;
        margin: 4px 0;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(150, 150, 150, 0.3);
        border-radius: 10px;
        transition: background 0.3s ease;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(150, 150, 150, 0.5);
      }

      /* Dark mode scrollbar */
      [data-theme="dark"]::-webkit-scrollbar-thumb {
        background: rgba(200, 200, 200, 0.2);
      }

      [data-theme="dark"]::-webkit-scrollbar-thumb:hover {
        background: rgba(200, 200, 200, 0.4);
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-primary);
        padding: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 100vh;
        transition: background-color 0.3s, color 0.3s;
        font-size: 11px;
      }

      .sidebar {
        background-color: var(--sidebar-bg);
        color: var(--text-primary);
        border-right: 1px solid transparent;
        height: 100vh;
        overflow-y: auto;
        width: 100%;
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
        /* More subtle appearance */
        backdrop-filter: blur(5px);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
      }

      /* Subtler dark mode sidebar */
      [data-theme="dark"] .sidebar {
        background-color: rgba(44, 44, 46, 0.9);
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
      }

      /* Main scrollable container */
      .main {
        padding: 0;
        flex: 1;
        overflow-y: auto;
        background-color: white;
      }

      button {
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--text-color);
        padding: 4px 8px;
        border-radius: 2px;
        display: flex;
        align-items: center;
        transition: background-color 0.2s;
        font-size: 10px;
      }

      button:hover {
        background-color: var(--figma-hover);
      }

      button.primary {
        background-color: var(--figma-blue);
        color: white;
        border-color: var(--figma-blue);
      }

      button.primary:hover {
        background-color: var(--figma-blue-hover);
        border-color: var(--figma-blue-hover);
      }

      button.danger {
        color: var(--danger-color);
      }

      button.danger:hover {
        background-color: rgba(242, 72, 34, 0.1);
      }

      button svg {
        margin-right: 4px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
      }

      .toolbar {
        display: flex;
        justify-content: space-between;
        padding: 6px 12px;
        border-bottom: 1px solid var(--border-color);
      }

      .toolbar-buttons {
        display: flex;
        gap: 8px;
      }

      .collection-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
        margin-bottom: 0;
        transition: background-color 0.2s ease;
        border-bottom: 0px solid rgba(0, 0, 0, 0.1);
      }
      .drag-handle {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 6px;
        cursor: move;
        opacity: 0.4;
        transition: opacity 0.2s ease;
      }

      .collection-header:hover .drag-handle {
        opacity: 0.8;
      }

      .collection-name {
        margin-left: 4px;
        flex: 1;
      }

      .collection-header.dragging {
        opacity: 0.6;
        background-color: var(--figma-color-bg-hover);
      }

      .collection-header.drag-over {
        border-top: 2px solid var(--figma-color-border-brand);
      }

      .active-collection .collection-header {
        color: var(--text-color);
        background-color: var(--active-color);
      }

      /* Add header right container for buttons and arrow */
      .collection-header-right {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .collection-name {
        display: flex;
        align-items: center;
        font-weight: 500;
        flex-grow: 1; /* Take up available space */
      }

      .collection-header:hover {
        background-color: var(--hover-color);
      }

      /* Style for collection actions */
      .collection-actions {
        display: flex;
        gap: 8px;
        transition: opacity 0.2s ease;
      }

      /* Make delete button more visible */
      .delete-collection-btn,
      .share-collection-btn {
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .delete-collection-btn:hover,
      .share-collection-btn:hover {
        opacity: 1;
      }

      .collection-header .arrow {
        transition: transform 0.2s;
        margin-left: 4px; /* Add space between buttons and arrow */
      }

      .collection-dimensions {
        margin-left: auto;
        font-size: 9px;
        color: var(--secondary-color);
        margin-right: 8px;
      }

      .collection-header .arrow.expanded {
        transform: rotate(90deg);
      }

      .collection-actions {
        display: flex;
        gap: 6px;
        opacity: 1;
      }

      .collection-content {
        overflow: hidden;
        max-height: 0;
        opacity: 0;
        transition: max-height 0.5s ease-out, opacity 0.4s ease;
        margin: 0;
        padding: 0;
      }

      .collection-content.expanded {
        max-height: 2000px;
        opacity: 1;
        border-top: none;
      }

      .arrow {
        transform: rotate(90deg);
        transition: transform 0.3s ease;
        display: inline-block;
        margin-left: 4px;
        font-size: 12px;
        color: var(--text-secondary);
      }

      .arrow.expanded {
        transform: rotate(180deg);
      }

      .presets-list {
        display: flex;
        flex-direction: column;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }

      .preset-card {
        padding: 8px 12px;
        cursor: pointer;
        position: relative;
        display: flex;
        align-items: center;
        transition: background-color 0.2s, transform 0.3s ease,
          opacity 0.3s ease;
        gap: 12px;
        opacity: 1;
        transform: translateX(0);
        height: auto;
        overflow: hidden;
        border: none;
      }

      /* Create animation classes for entry/exit */
      .preset-card-removing {
        opacity: 0;
        transform: translateX(-20px);
        height: 0;
        padding: 0;
        margin: 0;
        border: none;
      }

      .preset-preview {
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        width: auto;
        height: auto;
      }

      .preset-preview {
        flex-shrink: 0;
        margin-right: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .frame-visual {
        border: 1px solid #ddd;
        background-color: white;
        border-radius: 3px;
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        overflow: hidden;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }

      /* Dark mode adjustments for better readability */
      [data-theme="dark"] .frame-visual {
        border: 1px solid #555;
        background-color: #2a2a2a;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      [data-theme="dark"] .preset-name,
      [data-theme="dark"] .preset-dimensions {
        color: rgba(255, 255, 255, 0.9);
      }

      [data-theme="dark"] .preset-card:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }

      [data-theme="dark"] .collection-header {
        background-color: #2c2c2e;
        border-bottom: 1px solid #38383a;
      }

      [data-theme="dark"] .active-collection .collection-header {
        background-color: #2c4a67;
      }

      [data-theme="dark"] .collection-name {
        color: #ffffff;
      }

      [data-theme="dark"] button {
        color: #eeeeee;
      }

      [data-theme="dark"] button:hover {
        background-color: #3a3a3c;
      }

      [data-theme="dark"] .favorite-btn.active svg {
        fill: #ffcc33;
        stroke: #ffcc33;
      }

      .preset-name {
        flex-grow: 1;
        font-size: 11px;
        font-weight: 400;
        color: var(--text-primary);
      }

      .preset-info {
        flex: 1;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        overflow: hidden;
      }

      .preset-dimensions-row {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 8px;
        margin-left: auto;
        flex-shrink: 0;
      }

      .preset-dimensions {
        font-size: 10px;
        color: var(--text-secondary);
      }

      .preset-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: auto;
      }

      .favorite-btn,
      .delete-preset-btn,
      .preset-actions button,
      .collection-actions button {
        border: none;
        background: none;
        color: var(--secondary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 5px;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 24px;
        height: 24px;
        position: relative;
      }

      .preset-actions button svg,
      .collection-actions button svg {
        width: 14px;
        height: 14px;
      }

      .favorite-btn {
        color: var(--text-secondary);
        padding: 0;
        margin: 0;
        border-radius: 0;
        background: none;
        box-shadow: none;
        min-width: auto;
        min-height: auto;
        width: 16px;
        height: 16px;
        flex-shrink: 0;
        opacity: 10%;
      }

      .favorite-btn.active {
        color: var(--primary-color);
        background: none;
        box-shadow: none;
      }

      .favorite-btn svg {
        stroke: currentColor;
        stroke-width: 1.5px;
      }

      .delete-preset-btn:hover {
        background-color: var(--hover-color);
      }

      .favorite-btn:hover {
        background-color: transparent;
      }

      .delete-preset-btn {
        color: var(--text-secondary);
      }

      .delete-preset-btn:hover {
        color: var(--error-color);
      }

      .preset-name {
        font-size: 10px;
        font-weight: 500;
      }

      .preset-card:hover {
        background-color: var(--hover-color);
      }

      .preset-preview {
        background-color: var(--active-color);
        border-radius: 2px;
        margin-bottom: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 6px;
        aspect-ratio: 16/9;
        overflow: hidden;
      }

      .frame-visual {
        margin-bottom: 4px;
        box-shadow: 0 1px 3px var(--shadow-color);
      }

      .frame-dimensions {
        font-size: 9px;
        color: var(--secondary-color);
        text-align: center;
      }

      .preset-info {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      .preset-name {
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 60%;
        margin-right: 8px;
      }

      .preset-dimensions {
        font-size: 9px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }

      .favorite-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .preset-card:hover .favorite-btn {
        opacity: 1;
      }

      .favorite-btn.active {
        opacity: 1;
        color: #f2c94c;
      }

      .status-bar {
        border-top: 0.3px solid var(--border-color);
        padding: 8px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: auto;
      }

      .sync-status {
        font-size: 10px;
        color: var(--secondary-color);
      }

      .theme-toggle {
        cursor: pointer;
        color: var(--figma-secondary);
        padding: 4px;
      }

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
      }

      .modal.active {
        opacity: 1;
        pointer-events: auto;
      }

      .modal-content {
        background-color: var(--bg-color);
        border-radius: 4px;
        padding: 16px;
        width: 90%;
        max-width: 300px;
        box-shadow: 0 4px 12px var(--shadow-color);
      }

      .modal-header {
        font-weight: 600;
        margin-bottom: 16px;
        font-size: 12px;
      }

      .collection {
        border-bottom: 0.1px solid var(--border-color);
        border-top: none;
        margin: 0;
        padding: 0;
      }

      .collections-container {
        display: flex;
        flex-direction: column;
      }

      .collection:last-child {
        border-bottom: none;
      }

      .form-group {
        margin-bottom: 12px;
      }

      .form-group label {
        display: block;
        margin-bottom: 4px;
        font-weight: 500;
      }

      .form-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 2px;
        background-color: var(--bg-color);
        color: var(--text-color);
      }

      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 16px;
      }

      .favorites-section {
        border-bottom: 1px solid var(--border-color);
        max-height: 30vh;
        overflow-y: auto;
      }

      .empty-state {
        padding: 16px;
        text-align: center;
        color: var(--secondary-color);
        font-size: 11px;
      }

      .share-modal .share-link {
        background-color: var(--active-color);
        padding: 10px;
        border-radius: 4px;
        font-family: monospace;
        margin: 10px 0;
        word-break: break-all;
      }

      .copy-btn {
        margin-top: 8px;
        width: 100%;
        justify-content: center;
      }

      /* Loading animation */
      .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
      }

      .loading-spinner {
        border: 2px solid var(--border-color);
        border-top: 2px solid var(--accent-color);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
      }
    </style>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  </head>
  <body>
    <div class="sidebar">
      <div class="header">
        <h3>Frame Presets</h3>
        <div>
          <button
            id="create-preset-btn"
            class="primary"
            data-tooltip="Create preset from selected frame"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 1V11M1 6H11"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
              />
            </svg>
            Save Current Frame
          </button>
        </div>
      </div>

      <div class="toolbar">
        <div class="toolbar-buttons">
          <button
            id="new-collection-btn"
            data-tooltip="Create a new collection"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 1V11M1 6H11"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
              />
            </svg>
            New Collection
          </button>
          <button
            id="import-btn"
            data-tooltip="Import a collection from another user"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1 9L1 10C1 10.5523 1.44772 11 2 11L10 11C10.5523 11 11 10.5523 11 10L11 9M6 8L6 1M6 8L3.5 5.5M6 8L8.5 5.5"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Import
          </button>
          <button
            id="check-connection-btn"
            data-tooltip="Verify Supabase connection"
            style="margin-left: 8px"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10.5 6C10.5 8.48528 8.48528 10.5 6 10.5C3.51472 10.5 1.5 8.48528 1.5 6C1.5 3.51472 3.51472 1.5 6 1.5C8.48528 1.5 10.5 3.51472 10.5 6Z"
                stroke="currentColor"
                stroke-width="1.5"
              />
              <path
                d="M4 6L5.25 7.25L8 4.5"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Test Connection
          </button>
        </div>
        <button
          id="sync-btn"
          data-tooltip="Sync your collections with Supabase"
        >
          <svg
            width="12"
            height="12"
            viewBox="0 0 12 12"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M1 5.5C1 3.29086 2.79086 1.5 5 1.5C6.48052 1.5 7.77308 2.30205 8.46922 3.5M11 6.5C11 8.70914 9.20914 10.5 7 10.5C5.51948 10.5 4.22692 9.69795 3.53078 8.5"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
            />
            <path
              d="M9.5 1.5L8.5 3.5L10.5 3.5M2.5 10.5L3.5 8.5L1.5 8.5"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          Sync
        </button>
      </div>

      <div class="collections-container">
        <!-- Collections will be added here dynamically -->
        <div class="loading">
          <div class="loading-spinner"></div>
        </div>
      </div>

      <div class="status-bar">
        <div class="sync-status">Last synced: Never</div>
        <div class="theme-toggle" id="theme-toggle">
          <svg
            width="14"
            height="14"
            viewBox="0 0 14 14"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M7 1.5V1M7 13V12.5M12.5 7H13M1 7H1.5M10.8995 3.1005L11.2497 2.7503M2.7503 11.2497L3.1005 10.8995M10.8995 10.8995L11.2497 11.2497M2.7503 2.7503L3.1005 3.1005M9.5 7C9.5 8.38071 8.38071 9.5 7 9.5C5.61929 9.5 4.5 8.38071 4.5 7C4.5 5.61929 5.61929 4.5 7 4.5C8.38071 4.5 9.5 5.61929 9.5 7Z"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
            />
          </svg>
        </div>
      </div>
    </div>
    <!-- End of sidebar -->

    <!-- Create Collection Modal -->
    <div class="modal" id="new-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Create New Collection</div>
        <div class="form-group">
          <label for="collection-name">Collection Name</label>
          <input
            type="text"
            id="collection-name"
            placeholder="e.g., Web Banners"
          />
        </div>
        <div class="form-actions">
          <button id="cancel-collection-btn">Cancel</button>
          <button id="save-collection-btn" class="primary">Create</button>
        </div>
      </div>
    </div>

    <!-- Create Preset Modal -->
    <div class="modal" id="create-preset-modal">
      <div class="modal-content">
        <div class="modal-header">Save Frame Preset</div>
        <div id="preset-frames-container">
          <!-- Frame inputs will be added here dynamically -->
        </div>
        <div class="form-actions">
          <button id="cancel-preset-btn">Cancel</button>
          <button id="save-preset-btn" class="primary">Save</button>
        </div>
      </div>
    </div>

    <!-- Share Collection Modal -->
    <div class="modal share-modal" id="share-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Share Collection</div>
        <p>Share this ID with others to let them import your collection:</p>
        <div class="share-link" id="share-link">...</div>
        <button id="copy-share-link" class="copy-btn primary">
          Copy to Clipboard
        </button>
        <div class="form-actions">
          <button id="close-share-modal-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Import Collection Modal -->
    <div class="modal" id="import-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Import Collection</div>
        <div class="form-group">
          <label for="import-id">Collection ID</label>
          <input
            type="text"
            id="import-id"
            placeholder="Paste collection ID here"
          />
        </div>
        <div class="form-actions">
          <button id="cancel-import-btn">Cancel</button>
          <button id="import-collection-btn" class="primary">Import</button>
        </div>
      </div>
    </div>

    <!-- Supabase Configuration Modal -->
    <div class="modal" id="supabase-config-modal">
      <div class="modal-content">
        <div class="modal-header">Supabase Configuration</div>
        <div class="form-group">
          <label for="supabase-url">Supabase URL</label>
          <input
            type="text"
            id="supabase-url"
            placeholder="https://your-project.supabase.co"
          />
        </div>
        <div class="form-group">
          <label for="supabase-key">Supabase Anon Key</label>
          <input type="text" id="supabase-key" placeholder="your-anon-key" />
        </div>
        <div class="form-actions">
          <button id="cancel-supabase-btn">Cancel</button>
          <button id="save-supabase-btn" class="primary">Save</button>
        </div>
      </div>
    </div>

    <!-- Authentication Modal -->
    <div class="modal" id="auth-modal">
      <div class="modal-content">
        <div class="modal-header">Authentication Required</div>
        <div id="auth-form-container">
          <p class="auth-message">Please sign in to sync your collections</p>
          <div class="oauth-buttons">
            <button id="google-signin-btn" class="google-button">
              <img
                src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Google_%22G%22_Logo.svg/512px-Google_%22G%22_Logo.svg.png"
                alt="Google"
                style="width: 16px; height: 16px; margin-right: 8px"
              />
              Sign in with Google
            </button>
          </div>
          <div class="form-actions" style="margin-top: 16px">
            <button id="cancel-auth-btn">Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================================
      // Global state
      // ============================================================
      let pluginData = {
        collections: [],
        activeCollectionId: null,
        lastSyncedAt: null,
      };

      let theme = "light";
      let supabaseConfig = {
        url: null,
        key: null,
      };

      // Supabase client initialization
      let supabaseClient = null;

      async function initSupabase(url, key) {
        try {
          supabaseClient = supabase.createClient(url, key, {
            auth: {
              autoRefreshToken: true,
              persistSession: true,
              detectSessionInUrl: true,
            },
          });
          return true;
        } catch (error) {
          console.error("Failed to initialize Supabase:", error);
          return false;
        }
      }

      // ============================================================
      // DOM Elements
      // ============================================================
      // Global variables
      const collectionsContainer = document.querySelector(
        ".collections-container"
      );
      const themeToggle = document.getElementById("theme-toggle");
      const syncBtn = document.getElementById("sync-btn");
      const createPresetBtn = document.getElementById("create-preset-btn");
      const newCollectionBtn = document.getElementById("new-collection-btn");
      const importBtn = document.getElementById("import-btn");
      const checkConnectionBtn = document.getElementById(
        "check-connection-btn"
      );

      // Modal elements
      const newCollectionModal = document.getElementById(
        "new-collection-modal"
      );
      const collectionNameInput = document.getElementById("collection-name");
      const saveCollectionBtn = document.getElementById("save-collection-btn");
      const cancelCollectionBtn = document.getElementById(
        "cancel-collection-btn"
      );

      const createPresetModal = document.getElementById("create-preset-modal");
      const presetFramesContainer = document.getElementById(
        "preset-frames-container"
      );
      const savePresetBtn = document.getElementById("save-preset-btn");
      const cancelPresetBtn = document.getElementById("cancel-preset-btn");

      const shareCollectionModal = document.getElementById(
        "share-collection-modal"
      );
      const shareLink = document.getElementById("share-link");
      const copyShareLinkBtn = document.getElementById("copy-share-link");
      const closeShareModalBtn = document.getElementById(
        "close-share-modal-btn"
      );

      const importCollectionModal = document.getElementById(
        "import-collection-modal"
      );
      const importIdInput = document.getElementById("import-id");
      const importCollectionBtn = document.getElementById(
        "import-collection-btn"
      );
      const cancelImportBtn = document.getElementById("cancel-import-btn");

      const supabaseConfigModal = document.getElementById(
        "supabase-config-modal"
      );
      const supabaseUrlInput = document.getElementById("supabase-url");
      const supabaseKeyInput = document.getElementById("supabase-key");
      const saveSupabaseBtn = document.getElementById("save-supabase-btn");
      const cancelSupabaseBtn = document.getElementById("cancel-supabase-btn");

      // Auth Modal elements
      const authModal = document.getElementById("auth-modal");
      const googleSigninBtn = document.getElementById("google-signin-btn");
      const cancelAuthBtn = document.getElementById("cancel-auth-btn");

      // ============================================================
      // Helper Functions
      // ============================================================

      // Show a modal
      function showModal(modal) {
        modal.classList.add("active");
      }

      // Hide a modal
      function hideModal(modal) {
        modal.classList.remove("active");
      }

      // Generate a unique ID
      function generateId() {
        return Date.now().toString();
      }

      // Toggle collection expansion
      function toggleCollection(collectionId) {
        const arrow = document.querySelector(
          `.collection-${collectionId} .arrow`
        );
        const content = document.querySelector(
          `.collection-content-${collectionId}`
        );

        arrow.classList.toggle("expanded");
        content.classList.toggle("expanded");
      }

      // Toggle theme
      function toggleTheme() {
        if (theme === "light") {
          document.body.setAttribute("data-theme", "dark");
          theme = "dark";
        } else {
          document.body.removeAttribute("data-theme");
          theme = "light";
        }

        // Save theme preference
        parent.postMessage(
          { pluginMessage: { type: "theme-preference", theme } },
          "*"
        );
      }

      // Format dimensions for display
      function formatDimensions(width, height) {
        return `${Math.round(width)} × ${Math.round(height)}`;
      }

      // Calculate scale factor for frames to ensure consistent visual size
      function calculateScaleFactor(width, height) {
        const targetSize = 50; // Our target frame size (50x50px)
        const maxDimension = Math.max(width, height);

        // Scale down large frames
        if (maxDimension > targetSize) {
          return targetSize / maxDimension;
        }
        // Scale up small frames
        else if (maxDimension < targetSize) {
          return targetSize / maxDimension;
        }
        // Keep 1:1 if already at target size
        return 1;
      }

      // Supabase Integration
      async function setupSupabase() {
        if (!supabaseConfig.url || !supabaseConfig.key) {
          showModal(supabaseConfigModal);
          return false;
        }
        return true;
      }

      // Create Supabase client
      function createSupabaseClient() {
        // This is a simplified version since we can't include the actual Supabase client library
        // In a real implementation, you would use the Supabase JS client
        return {
          from: (table) => {
            return {
              select: () => Promise.resolve([]),
              insert: (data) => Promise.resolve(data),
              update: (data) => Promise.resolve(data),
              delete: () => Promise.resolve(true),
              eq: () => this,
            };
          },
          auth: {
            getSession: () => Promise.resolve(null),
          },
        };
      }

      // Sync data to Supabase
      async function syncToSupabase() {
        if (!supabaseClient) {
          const url = supabaseUrlInput.value.trim();
          const key = supabaseKeyInput.value.trim();

          if (!url || !key) {
            showModal(supabaseConfigModal);
            return false;
          }

          const success = await initSupabase(url, key);
          if (!success) {
            showErrorMessage("Failed to initialize Supabase");
            return false;
          }

          // Save config using Figma's storage via message passing
          parent.postMessage(
            {
              pluginMessage: {
                type: "save-supabase-config",
                url: url,
                key: key,
              },
            },
            "*"
          );
        }

        try {
          // First check if we have an authenticated session
          const { data: authData, error: sessionError } =
            await supabaseClient.auth.getSession();

          console.log(
            "Auth check result:",
            sessionError ? "Error" : "Success",
            authData
          );

          // If there's no valid session, show the auth modal
          if (sessionError || !authData.session || !authData.session.user) {
            console.log("No active session found, authentication required");
            showModal(authModal);
            return false;
          }

          const userId = authData.session.user.id;
          console.log("User authenticated with ID:", userId);

          // Delete existing non-built-in collections first
          const { error: deleteError } = await supabaseClient
            .from("collections")
            .delete()
            .eq("user_id", userId)
            .not("is_built_in", true);

          if (deleteError) {
            console.error("Error deleting existing collections:", deleteError);
            showErrorMessage("Error during sync: " + deleteError.message);
            return false;
          }

          // Prepare collections data with user_id
          const collectionsToSync = pluginData.collections
            .filter((collection) => !collection.isBuiltIn)
            .map((collection) => ({
              id: collection.id,
              name: collection.name,
              presets: collection.presets,
              is_built_in: collection.isBuiltIn || false,
              user_id: userId, // Explicitly set user_id to match authenticated user
              last_synced_at: new Date().toISOString(),
            }));

          console.log("Syncing collections:", collectionsToSync.length);

          // If no collections to sync, just return success
          if (collectionsToSync.length === 0) {
            // Update sync status even though no data was synced
            const now = new Date();
            document.querySelector(
              ".sync-status"
            ).textContent = `Last synced: ${now.toLocaleTimeString()}`;
            pluginData.lastSyncedAt = now.getTime();
            return true;
          }

          // Insert collections with user_id
          const { error: upsertError } = await supabaseClient
            .from("collections")
            .upsert(collectionsToSync, {
              onConflict: "id", // Handle conflicts by ID
              ignoreDuplicates: false, // Update existing records
            });

          if (upsertError) {
            console.error("Upsert error:", upsertError);
            showErrorMessage("Error during sync: " + upsertError.message);
            return false;
          }

          // Update sync status
          const now = new Date();
          document.querySelector(
            ".sync-status"
          ).textContent = `Last synced: ${now.toLocaleTimeString()}`;
          pluginData.lastSyncedAt = now.getTime();

          // Notify Figma
          parent.postMessage(
            {
              pluginMessage: {
                type: "sync-to-supabase",
                success: true,
              },
            },
            "*"
          );

          return true;
        } catch (error) {
          console.error("Sync error:", error);
          showErrorMessage("Failed to sync: " + error.message);
          return false;
        }
      }

      // Add function to import from Supabase
      async function importFromSupabase() {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          return false;
        }

        try {
          // First check if we have an authenticated session
          const { data: authData, error: sessionError } =
            await supabaseClient.auth.getSession();

          console.log(
            "Auth check result:",
            sessionError ? "Error" : "Success",
            authData
          );

          // If there's no valid session, show the auth modal
          if (sessionError || !authData.session || !authData.session.user) {
            console.log("No active session found, authentication required");
            showModal(authModal);
            return false;
          }

          const userId = authData.session.user.id;
          console.log("User authenticated with ID:", userId);

          // Only get collections that belong to this user (enforcing userId requirement)
          const { data, error } = await supabaseClient
            .from("collections")
            .select("*")
            .eq("user_id", userId)
            .order("created_at", { ascending: true });

          if (error) {
            console.error("Import query error:", error);
            showErrorMessage("Error during import: " + error.message);
            return false;
          }

          if (!data || data.length === 0) {
            showErrorMessage("No collections found for your account");
            return false;
          }

          console.log("Found collections to import:", data.length);

          // Merge with existing collections, avoiding duplicates
          const existingIds = new Set(pluginData.collections.map((c) => c.id));
          const newCollections = data.filter((c) => !existingIds.has(c.id));

          // If all collections exist already
          if (newCollections.length === 0) {
            showErrorMessage("All collections already exist in your workspace");
            return true;
          }

          // Add the collections
          pluginData.collections = [
            ...pluginData.collections,
            ...newCollections,
          ];

          // Update UI
          renderCollections();

          // Notify Figma
          parent.postMessage(
            {
              pluginMessage: {
                type: "update",
                data: pluginData,
              },
            },
            "*"
          );

          return true;
        } catch (error) {
          console.error("Import error:", error);
          showErrorMessage("Failed to import: " + error.message);
          return false;
        }
      }

      // Add function to import from Supabase using a share code
      async function importSharedCollection() {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          // Focus the input field again
          setTimeout(() => importIdInput.focus(), 10);
          return false;
        }

        try {
          // Get the share code from the input and save it in a variable
          const shareCode = importIdInput.value.trim();
          if (!shareCode) {
            showErrorMessage("Please enter a valid share code");
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Show loading state
          importCollectionBtn.disabled = true;
          importCollectionBtn.textContent = "Importing...";

          // Debug log the actual input
          console.log("Attempting import with code:", shareCode);

          let query;
          let queryType = "unknown";

          // Check if the input is a full UUID in standard format (8-4-4-4-12 characters)
          const uuidPattern =
            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

          if (uuidPattern.test(shareCode)) {
            // If it's a full UUID, do an exact match
            query = supabaseClient
              .from("shared_collections")
              .select("*")
              .eq("share_id", shareCode);

            queryType = "exact-uuid";
            console.log("Using exact UUID match for:", shareCode);
          } else {
            // Otherwise, try the partial match approach
            query = supabaseClient
              .from("shared_collections")
              .select("*")
              .ilike("share_id", `${shareCode}%`);

            queryType = "partial-match";
            console.log("Using partial match for:", shareCode);
          }

          // Debug log the query before executing
          console.log(`Executing ${queryType} query...`);

          // Execute the query
          const { data: sharedCollections, error: fetchError } = await query;

          console.log("Query results:", {
            queryType,
            count: sharedCollections?.length || 0,
            error: fetchError?.message,
          });

          // Restore button state
          importCollectionBtn.disabled = false;
          importCollectionBtn.textContent = "Import";

          if (fetchError) {
            console.error(
              "Database error fetching shared collection:",
              fetchError
            );
            showErrorMessage("Database error: " + fetchError.message);
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          if (!sharedCollections || sharedCollections.length === 0) {
            console.error("No collection found with ID:", shareCode);
            showErrorMessage(
              "Collection not found with this code. Make sure you entered it correctly."
            );
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Use the first result
          const sharedCollection = sharedCollections[0];
          console.log("Found collection:", sharedCollection?.name);

          if (
            !sharedCollection.presets ||
            !Array.isArray(sharedCollection.presets)
          ) {
            console.error(
              "Invalid collection format - missing presets:",
              sharedCollection
            );
            showErrorMessage("The imported collection has an invalid format.");
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Check if this collection already exists
          const collectionExists = pluginData.collections.some(
            (c) => c.id === sharedCollection.collection_id
          );

          if (collectionExists) {
            console.log("Collection already exists in workspace");
            showErrorMessage("This collection is already in your workspace");
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Create a new copy of the collection with a new ID to avoid conflicts
          const newCollection = {
            id: "collection-" + Date.now(), // New unique ID
            name: sharedCollection.name + " (Shared)",
            presets: sharedCollection.presets || [], // Ensure we have an array
            isBuiltIn: false,
          };

          console.log("Created new collection object:", {
            id: newCollection.id,
            name: newCollection.name,
            presetCount: newCollection.presets.length,
          });

          // Add the collection to the local data
          pluginData.collections.push(newCollection);

          // Update UI
          console.log("Updating UI with new collection");
          renderCollections();

          // Notify Figma
          console.log("Notifying Figma plugin code about new collection");
          parent.postMessage(
            {
              pluginMessage: {
                type: "update",
                data: pluginData,
              },
            },
            "*"
          );

          // Close modal and show success message
          hideModal(importCollectionModal);
          showSuccessMessage("Collection imported successfully");

          // Reset input for next time
          importIdInput.value = "";

          return true;
        } catch (error) {
          console.error("Import error:", error);
          showErrorMessage(
            "Failed to import: " + (error.message || "Unknown error")
          );

          // Restore button state
          importCollectionBtn.disabled = false;
          importCollectionBtn.textContent = "Import";

          // Focus the input field again
          setTimeout(() => importIdInput.focus(), 10);
          return false;
        }
      }

      // ============================================================
      // Rendering Functions
      // ============================================================

      // Setup drag and drop functionality for collections
      function setupCollectionDragAndDrop() {
        let draggingElement = null;
        let previousOrder = [];

        // Store the current order of collections
        function saveCurrentOrder() {
          const collections = document.querySelectorAll(".collection");
          previousOrder = Array.from(collections)
            .filter((el) => el.querySelector(".collection-header"))
            .map((el) => el.querySelector(".collection-header").dataset.id);
          return previousOrder;
        }

        // Save new order to Figma
        function saveNewOrder() {
          const collections = document.querySelectorAll(".collection");
          const newOrder = Array.from(collections)
            .filter((el) => el.querySelector(".collection-header"))
            .map((el) => el.querySelector(".collection-header").dataset.id)
            .filter((id) => id !== "favorites"); // Filter out the favorites virtual collection

          console.log("Previous order:", previousOrder);
          console.log("New order:", newOrder);

          // Always send the reorder message to make sure it's processed
          parent.postMessage(
            {
              pluginMessage: {
                type: "reorder-collections",
                collectionIds: newOrder,
              },
            },
            "*"
          );
        }

        // Setup drag and drop for each collection header
        document.querySelectorAll(".collection-header").forEach((header) => {
          // Skip favorites collection which shouldn't be draggable
          if (header.dataset.id === "favorites") {
            header.setAttribute("draggable", "false");
            return;
          }

          // Dragstart - when user starts dragging
          header.addEventListener("dragstart", (e) => {
            draggingElement = header.closest(".collection");
            draggingElement.classList.add("dragging");

            // Set data for drag operation
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", header.dataset.id);

            // Store current order
            saveCurrentOrder();

            // Add delay for visual feedback
            setTimeout(() => {
              draggingElement.style.opacity = "0.6";
            }, 0);
          });

          // Dragend - when user releases the element
          header.addEventListener("dragend", () => {
            if (draggingElement) {
              draggingElement.classList.remove("dragging");
              draggingElement.style.opacity = "1";
              draggingElement = null;

              // Remove drag-over styling
              document.querySelectorAll(".collection-header").forEach((h) => {
                h.classList.remove("drag-over");
              });

              // Save the new order
              saveNewOrder();
            }
          });

          // Dragover - as dragged element moves over potential drop targets
          header.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";

            const container = header.closest(".collection");
            if (
              container !== draggingElement &&
              header.dataset.id !== "favorites"
            ) {
              header.classList.add("drag-over");
            }
          });

          // Dragleave - when dragged element leaves a potential drop target
          header.addEventListener("dragleave", () => {
            header.classList.remove("drag-over");
          });

          // Drop - when element is dropped
          header.addEventListener("drop", (e) => {
            e.preventDefault();
            header.classList.remove("drag-over");

            if (!draggingElement) return;

            const targetContainer = header.closest(".collection");
            if (
              targetContainer !== draggingElement &&
              header.dataset.id !== "favorites"
            ) {
              const containers = Array.from(
                document.querySelectorAll(".collection")
              );
              const dragIndex = containers.indexOf(draggingElement);
              const targetIndex = containers.indexOf(targetContainer);

              // Determine if we need to insert before or after
              if (dragIndex < targetIndex) {
                document
                  .querySelector(".collections-container")
                  .insertBefore(draggingElement, targetContainer.nextSibling);
              } else {
                document
                  .querySelector(".collections-container")
                  .insertBefore(draggingElement, targetContainer);
              }
            }
          });
        });
      }

      // Render all collections
      function renderCollections() {
        collectionsContainer.innerHTML = "";

        // Check if pluginData exists before proceeding
        if (!pluginData || !pluginData.collections) {
          collectionsContainer.innerHTML = `<div class="empty-state">Loading collections...</div>`;
          return;
        }

        // Create a virtual Favorites collection at the top
        const favorites = [];

        // Get all favorite presets across collections
        pluginData.collections.forEach((collection) => {
          collection.presets.forEach((preset) => {
            if (preset.isFavorite) {
              favorites.push({
                ...preset,
                collectionId: collection.id,
                collectionName: collection.name,
              });
            }
          });
        });

        // Add Favorites as a virtual collection
        if (favorites.length > 0) {
          const favoritesEl = document.createElement("div");
          favoritesEl.classList.add(`collection`);
          favoritesEl.classList.add(`collection-favorites`);

          // Create favorites collection header
          favoritesEl.innerHTML = `
          <div class="collection-header" data-id="favorites">
            <div class="collection-name">
              <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 6px">
                <path d="M5.95 1.37724C5.9776 1.32251 6.0224 1.32251 6.05 1.37724L7.5595 4.42717C7.57224 4.45394 7.59776 4.47125 7.62709 4.47456L10.9639 4.92686C11.0243 4.93462 11.0463 5.00876 11.0012 5.0529L8.55513 7.42616C8.53316 7.44749 8.52325 7.47852 8.52855 7.50779L9.12376 10.8254C9.13402 10.8855 9.07045 10.9328 9.01734 10.9054L6.07474 9.36736C6.0479 9.35256 6.0141 9.35438 5.98869 9.37122L3.10501 11.0304C3.05287 11.0608 2.98701 11.0163 2.99478 10.9559L3.47124 7.61922C3.47551 7.58973 3.46456 7.55909 3.44183 7.53851L0.9422 5.24822C0.895218 5.20623 0.914854 5.13149 0.97477 5.12181L4.29308 4.54424C4.32225 4.53993 4.34671 4.52183 4.35816 4.49471L5.95 1.37724Z" fill="currentColor" stroke="currentColor" stroke-width="1.5"/>
              </svg>
              Favorites
            </div>
            <div class="arrow expanded">›</div>
          </div>
          <div class="collection-content expanded" data-collection-id="favorites">
            <div class="presets-list">
              ${favorites
                .map(
                  (preset) => `
                <div class="preset-card" data-id="${
                  preset.id
                }" data-collection="${preset.collectionId}">
                  <div class="preset-preview">
                    <div class="frame-visual"></div>
                  </div>
                  <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-dimensions-row">
                      <button class="favorite-btn active" data-id="${
                        preset.id
                      }" data-collection="${preset.collectionId}">
                        <svg width="16" height="16" viewBox="0 0 12 12" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                          <path d="M5.95 1.37724C5.9776 1.32251 6.0224 1.32251 6.05 1.37724L7.5595 4.42717C7.57224 4.45394 7.59776 4.47125 7.62709 4.47456L10.9639 4.92686C11.0243 4.93462 11.0463 5.00876 11.0012 5.0529L8.55513 7.42616C8.53316 7.44749 8.52325 7.47852 8.52855 7.50779L9.12376 10.8254C9.13402 10.8855 9.07045 10.9328 9.01734 10.9054L6.07474 9.36736C6.0479 9.35256 6.0141 9.35438 5.98869 9.37122L3.10501 11.0304C3.05287 11.0608 2.98701 11.0163 2.99478 10.9559L3.47124 7.61922C3.47551 7.58973 3.46456 7.55909 3.44183 7.53851L0.9422 5.24822C0.895218 5.20623 0.914854 5.13149 0.97477 5.12181L4.29308 4.54424C4.32225 4.53993 4.34671 4.52183 4.35816 4.49471L5.95 1.37724Z" fill="currentColor" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                      </button>
                      <div class="preset-dimensions">${formatDimensions(
                        preset.width,
                        preset.height
                      )}</div>
                    </div>
                  </div>
                  <!-- No delete button in favorites -->
                </div>
              `
                )
                .join("")}
            </div>
          </div>
          `;

          collectionsContainer.appendChild(favoritesEl);
        }

        // Then render all regular collections
        pluginData.collections.forEach((collection) => {
          const isActive = collection.id === pluginData.activeCollectionId;
          const collectionEl = document.createElement("div");
          collectionEl.classList.add(`collection`);
          collectionEl.classList.add(`collection-${collection.id}`);

          // Add active class if this collection is active
          if (isActive) {
            collectionEl.classList.add("active-collection");
          }

          // Create collection header in a style similar to the screenshot
          collectionEl.innerHTML = `
          <div class="collection-header" data-id="${
            collection.id
          }" draggable="true">
            <div class="drag-handle">
              <svg width="10" height="10" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 5H5M7 10H5M7 15H5M15 5H13M15 10H13M15 15H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <div class="collection-name">
              ${collection.name}
            </div>
            <div class="collection-header-right">
              <div class="collection-actions">
                <button class="share-collection-btn" data-id="${
                  collection.id
                }" data-tooltip="Share collection">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.68439 10.6578L15.3124 7.34378M15.3156 16.6578L8.69376 13.3469M21 6C21 7.65685 19.6569 9 18 9C16.3431 9 15 7.65685 15 6C15 4.34315 16.3431 3 18 3C19.6569 3 21 4.34315 21 6ZM21 18C21 19.6569 19.6569 21 18 21C16.3431 21 15 19.6569 15 18C15 16.3431 16.3431 15 18 15C19.6569 15 21 16.3431 21 18ZM9 12C9 13.6569 7.65685 15 6 15C4.34315 15 3 13.6569 3 12C3 10.3431 4.34315 9 6 9C7.65685 9 9 10.3431 9 12Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="delete-collection-btn" data-id="${
                  collection.id
                }" data-tooltip="Delete collection">
                  <svg width="14" height="14" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M1 3H11M4 3V2.5C4 1.67157 4.67157 1 5.5 1H6.5C7.32843 1 8 1.67157 8 2.5V3M9 3V10C9 10.5523 8.55228 11 8 11H4C3.44772 11 3 10.5523 3 10V3" stroke="currentColor" stroke-width="1.5"/>
                  </svg>
                </button>
              </div>
              <div class="arrow" data-tooltip="Expand/Collapse">›</div>
            </div>
          </div>
          <div class="collection-content" data-collection-id="${collection.id}">
            <div class="presets-list">
              ${
                collection.presets.length > 0
                  ? collection.presets
                      .map(
                        (preset) => `
                <div class="preset-card" data-id="${
                  preset.id
                }" data-collection="${collection.id}">
                  <div class="preset-preview">
                    <div class="frame-visual"></div>
                  </div>
                  <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-dimensions-row">
                      <button class="favorite-btn ${
                        preset.isFavorite ? "active" : ""
                      }" data-id="${preset.id}" data-collection="${
                          collection.id
                        }" data-tooltip="${
                          preset.isFavorite
                            ? "Remove from favorites"
                            : "Add to favorites"
                        }">
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="${
                          preset.isFavorite ? "currentColor" : "none"
                        }" xmlns="http://www.w3.org/2000/svg">
                          <path d="M5.95 1.37724C5.9776 1.32251 6.0224 1.32251 6.05 1.37724L7.5595 4.42717C7.57224 4.45394 7.59776 4.47125 7.62709 4.47456L10.9639 4.92686C11.0243 4.93462 11.0463 5.00876 11.0012 5.0529L8.55513 7.42616C8.53316 7.44749 8.52325 7.47852 8.52855 7.50779L9.12376 10.8254C9.13402 10.8855 9.07045 10.9328 9.01734 10.9054L6.07474 9.36736C6.0479 9.35256 6.0141 9.35438 5.98869 9.37122L3.10501 11.0304C3.05287 11.0608 2.98701 11.0163 2.99478 10.9559L3.47124 7.61922C3.47551 7.58973 3.46456 7.55909 3.44183 7.53851L0.9422 5.24822C0.895218 5.20623 0.914854 5.13149 0.97477 5.12181L4.29308 4.54424C4.32225 4.53993 4.34671 4.52183 4.35816 4.49471L5.95 1.37724Z" fill="${
                            preset.isFavorite ? "currentColor" : "transparent"
                          }" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                      </button>
                      <div class="preset-dimensions">${formatDimensions(
                        preset.width,
                        preset.height
                      )}</div>
                    </div>
                  </div>
                  ${
                    !collection.isBuiltIn && preset.dateCreated > 1000000000000
                      ? `
                  <div class="preset-actions">
                    <button class="delete-preset-btn" data-id="${preset.id}" data-collection="${collection.id}" data-tooltip="Delete preset">
                      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 3H10M4 3V2.5C4 1.67157 4.67157 1 5.5 1H6.5C7.32843 1 8 1.67157 8 2.5V3M9 3V10C9 10.5523 8.55228 11 8 11H4C3.44772 11 3 10.5523 3 10V3" stroke="currentColor" stroke-width="1.5"/>
                      </svg>
                    </button>
                  </div>
                  `
                      : ""
                  }                </div>
              `
                      )
                      .join("")
                  : `<div class="empty-state" style="border: none; border-top: none; border-bottom: none;">No presets in this collection. Create one using the "Save Current Frame" button.</div>`
              }
            </div>
          </div>
        `;

          collectionsContainer.appendChild(collectionEl);
        });

        // Set up event listeners for the newly created elements
        setupCollectionEventListeners();

        // Setup drag and drop for collection reordering
        setupCollectionDragAndDrop();

        // Render the frame visuals for each preset
        document.querySelectorAll(".frame-visual").forEach((visual) => {
          const card = visual.closest(".preset-card");
          if (!card) return;

          const presetId = card.dataset.id;
          const collectionId = card.dataset.collection;

          // Find the preset data
          const collection = pluginData.collections.find(
            (c) => c.id === collectionId
          );
          if (!collection) return;

          const preset = collection.presets.find((p) => p.id === presetId);
          if (!preset) return;

          // Calculate scale for the visual representation
          const scaleFactor = calculateScaleFactor(preset.width, preset.height);

          // Set the visual style to match the frame dimensions proportionally
          const frameWidth = preset.width * scaleFactor;
          const frameHeight = preset.height * scaleFactor;

          visual.style.width = `${frameWidth}px`;
          visual.style.height = `${frameHeight}px`;
        });
      }

      // Favorites are now handled directly inside the renderCollections function

      // Set up event listeners for collection elements
      function setupCollectionEventListeners() {
        // Collection header click - makes collection active and toggles expansion
        document.querySelectorAll(".collection-header").forEach((header) => {
          header.addEventListener("click", (e) => {
            // Stop event propagation to prevent any parent handlers from firing
            e.stopPropagation();

            // Skip if clicking on action buttons
            if (
              e.target.closest(".collection-actions") ||
              e.target.closest("button")
            ) {
              return;
            }

            const collectionId = header.getAttribute("data-id");
            if (collectionId) {
              // First handle the UI expansion
              // Toggle arrow state
              const arrow = header.querySelector(".arrow");
              if (arrow) {
                arrow.classList.toggle("expanded");
              }

              // Find and toggle the associated content div by data attribute
              const contentDiv = document.querySelector(
                `.collection-content[data-collection-id="${collectionId}"]`
              );
              if (contentDiv) {
                contentDiv.classList.toggle("expanded");
              }

              // Then notify Figma about active collection change
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "set-active-collection",
                    collectionId: collectionId,
                    // Add a flag to indicate this is just an active state change, not a full refresh
                    preserveUIState: true,
                  },
                },
                "*"
              );
            }
          });
        });

        // Delete collection
        document.querySelectorAll(".delete-collection-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const collectionId = btn.getAttribute("data-id");

            if (confirm("Are you sure you want to delete this collection?")) {
              // Notify Figma
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "delete-collection",
                    collectionId: collectionId,
                  },
                },
                "*"
              );
            }
          });
        });

        // Share collection
        document.querySelectorAll(".share-collection-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const collectionId = btn.getAttribute("data-id");
            shareCollection(collectionId);
          });
        });

        // Preset card click (use preset)
        document.querySelectorAll(".preset-card").forEach((card) => {
          card.addEventListener("click", (e) => {
            // Don't use preset if clicking the favorite button
            if (e.target.closest(".favorite-btn")) return;

            const presetId = card.dataset.id;
            const collectionId = card.dataset.collection;

            const collection = pluginData.collections.find(
              (c) => c.id === collectionId
            );
            if (!collection) return;

            const preset = collection.presets.find((p) => p.id === presetId);
            if (!preset) return;

            // Notify Figma to use this preset on the selected frame
            parent.postMessage(
              {
                pluginMessage: {
                  type: "use-preset",
                  preset,
                  applyToSelection: true, // Flag to apply to selected frame instead of creating new
                },
              },
              "*"
            );
          });
        });

        // Delete preset button click
        document.querySelectorAll(".delete-preset-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const presetId = btn.getAttribute("data-id");
            const collectionId = btn.getAttribute("data-collection");

            // Get the current expanded state to preserve it during animation
            saveExpandedState();

            // Add a removing animation
            const card = btn.closest(".preset-card");
            if (card) {
              card.classList.add("preset-card-removing");
            }

            // Notify Figma after a short delay for animation
            setTimeout(() => {
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "delete-preset",
                    presetId: presetId,
                    collectionId: collectionId,
                  },
                },
                "*"
              );
            }, 100);
          });
        });

        // Favorite button click
        document.querySelectorAll(".favorite-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const presetId = e.currentTarget.dataset.id;
            const collectionId = e.currentTarget.dataset.collection;
            const card = e.currentTarget.closest(".preset-card");

            // Get the current expanded state to preserve it during animation
            saveExpandedState();

            // Toggle the favorite state visually immediately for instant feedback
            const isFavorite = e.currentTarget.classList.contains("active");
            if (isFavorite) {
              e.currentTarget.classList.remove("active");
              const svg = e.currentTarget.querySelector("svg");
              if (svg) svg.setAttribute("fill", "transparent");

              // If removing from favorites section, animate removal
              if (
                card &&
                document.querySelector(".favorites-section") &&
                card.closest(".favorites-section")
              ) {
                card.classList.add("preset-card-removing");
                // Wait for animation before notifying Figma
                setTimeout(() => {
                  // Notify Figma only after animation starts
                  parent.postMessage(
                    {
                      pluginMessage: {
                        type: "toggle-favorite",
                        presetId,
                        collectionId,
                      },
                    },
                    "*"
                  );
                }, 100); // Short delay for animation to start
                return;
              }
            } else {
              e.currentTarget.classList.add("active");
              const svg = e.currentTarget.querySelector("svg");
              if (svg) svg.setAttribute("fill", "currentColor");
            }

            // Notify Figma for normal cases
            parent.postMessage(
              {
                pluginMessage: {
                  type: "toggle-favorite",
                  presetId,
                  collectionId,
                },
              },
              "*"
            );
          });
        });
      }

      // ============================================================
      // Event Listeners
      // ============================================================

      // Theme toggle
      themeToggle.addEventListener("click", toggleTheme);

      // Create new collection
      newCollectionBtn.addEventListener("click", () => {
        collectionNameInput.value = "";
        showModal(newCollectionModal);
      });

      // Save new collection
      saveCollectionBtn.addEventListener("click", () => {
        const name = collectionNameInput.value.trim();
        if (!name) return;

        // Notify Figma
        parent.postMessage(
          {
            pluginMessage: {
              type: "create-collection",
              name,
            },
          },
          "*"
        );

        hideModal(newCollectionModal);

        // If we have a flag to create preset after collection, trigger the preset creation
        if (window.createPresetAfterCollection) {
          // Reset the flag
          window.createPresetAfterCollection = false;

          // Set a timeout to allow the collection to be created first
          setTimeout(() => {
            // We'll request the current selection data from Figma
            // The targetCollectionId will be set in the onmessage handler when we get the update
            parent.postMessage(
              {
                pluginMessage: {
                  type: "create-preset",
                },
              },
              "*"
            );
          }, 300);
        }
      });

      // Cancel new collection
      cancelCollectionBtn.addEventListener("click", () => {
        hideModal(newCollectionModal);
      });

      // Create preset
      createPresetBtn.addEventListener("click", () => {
        // First check if any custom collections exist
        const customCollections = pluginData.collections.filter(
          (c) => !c.isBuiltIn
        );

        // If no custom collections exist, prompt to create one
        if (customCollections.length === 0) {
          if (
            confirm(
              "You need to create a collection first to save frames. Would you like to create one now?"
            )
          ) {
            collectionNameInput.value = "";
            showModal(newCollectionModal);

            // Set a flag to indicate we should create a preset after collection is created
            window.createPresetAfterCollection = true;
          }
          return;
        }

        // If no active collection or active collection is built-in, use the first custom collection
        const activeCollection = pluginData.collections.find(
          (c) => c.id === pluginData.activeCollectionId
        );
        let targetCollectionId = pluginData.activeCollectionId;

        if (!activeCollection || activeCollection.isBuiltIn) {
          targetCollectionId = customCollections[0].id;
          console.log("Using first custom collection:", targetCollectionId);
        }

        // Request current selection from Figma
        parent.postMessage(
          {
            pluginMessage: {
              type: "create-preset",
              targetCollectionId: targetCollectionId,
            },
          },
          "*"
        );
      });

      // Save preset
      savePresetBtn.addEventListener("click", () => {
        // Get all frame inputs
        const frameInputGroups =
          document.querySelectorAll(".frame-input-group");

        if (frameInputGroups.length === 0) {
          showErrorMessage("No frames to save");
          return;
        }

        // Store original frame data that came from Figma
        const originalFrameData = window.currentFrameData || [];

        // Loop through each frame input group
        frameInputGroups.forEach((group, index) => {
          const nameInput = group.querySelector(".frame-name-input");
          const widthInput = group.querySelector(".frame-width-input");
          const heightInput = group.querySelector(".frame-height-input");

          if (!nameInput || !widthInput || !heightInput) {
            console.error("Missing input fields");
            return;
          }

          // Get input values
          const name = nameInput.value.trim();
          const width = parseFloat(widthInput.value);
          const height = parseFloat(heightInput.value); // Fixed: using heightInput.value instead of widthInput

          // Validate
          if (name && !isNaN(width) && !isNaN(height)) {
            // Create preset with ALL properties from the original frame
            const originalFrame = originalFrameData[index] || {};

            const preset = {
              id: generateId(),
              name: name,
              width: width,
              height: height,
              isFavorite: false,
              dateCreated: Date.now(),

              // Include all other frame properties from original data
              fills: originalFrame.fills,
              strokes: originalFrame.strokes,
              strokeWeight: originalFrame.strokeWeight,
              cornerRadius: originalFrame.cornerRadius,
              effects: originalFrame.effects,
              layoutMode: originalFrame.layoutMode,
              primaryAxisSizingMode: originalFrame.primaryAxisSizingMode,
              counterAxisSizingMode: originalFrame.counterAxisSizingMode,
              primaryAxisAlignItems: originalFrame.primaryAxisAlignItems,
              counterAxisAlignItems: originalFrame.counterAxisAlignItems,
              paddingLeft: originalFrame.paddingLeft,
              paddingRight: originalFrame.paddingRight,
              paddingTop: originalFrame.paddingTop,
              paddingBottom: originalFrame.paddingBottom,
              itemSpacing: originalFrame.itemSpacing,
              clipsContent: originalFrame.clipsContent,
            };

            // Notify Figma
            parent.postMessage(
              {
                pluginMessage: {
                  type: "save-preset",
                  preset,
                  collectionId: pluginData.activeCollectionId,
                },
              },
              "*"
            );
          }
        });

        hideModal(createPresetModal);
      });

      // Cancel preset
      cancelPresetBtn.addEventListener("click", () => {
        hideModal(createPresetModal);
      });

      // Import button
      importBtn.addEventListener("click", () => {
        importIdInput.value = "";
        showModal(importCollectionModal);
      });

      // Import collection
      importCollectionBtn.addEventListener("click", async () => {
        const success = await importSharedCollection();
        if (success) {
          hideModal(importCollectionModal);
          showSuccessMessage("Collection imported successfully");
        } else {
          showErrorMessage("Failed to import collection");
        }
      });

      // Cancel import
      cancelImportBtn.addEventListener("click", () => {
        hideModal(importCollectionModal);
      });

      // Copy share link
      copyShareLinkBtn.addEventListener("click", () => {
        try {
          // Method 1: Modern Clipboard API
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard
              .writeText(shareLink.textContent)
              .then(() => {
                copyShareLinkBtn.textContent = "Copied!";
                setTimeout(() => {
                  copyShareLinkBtn.textContent = "Copy to Clipboard";
                }, 2000);
              })
              .catch((err) => fallbackCopyToClipboard(shareLink.textContent));
          } else {
            // Method 2: Selection and execCommand
            fallbackCopyToClipboard(shareLink.textContent);
          }
        } catch (err) {
          console.error("Copy failed:", err);
          showErrorMessage(
            "Failed to copy. Please select and copy the text manually."
          );
        }
      });

      // Fallback copy method using selection
      function fallbackCopyToClipboard(text) {
        // Create temporary textarea
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.width = "2em";
        textArea.style.height = "2em";
        textArea.style.padding = "0";
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.style.boxShadow = "none";
        textArea.style.background = "transparent";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          const successful = document.execCommand("copy");
          if (successful) {
            copyShareLinkBtn.textContent = "Copied!";
            setTimeout(() => {
              copyShareLinkBtn.textContent = "Copy to Clipboard";
            }, 2000);
          } else {
            console.error("Copy command was unsuccessful");
          }
        } catch (err) {
          console.error("Error during copy:", err);
        }

        document.body.removeChild(textArea);
      }

      // Close share modal
      closeShareModalBtn.addEventListener("click", () => {
        hideModal(shareCollectionModal);
      });

      // Sync button
      syncBtn.addEventListener("click", async () => {
        const success = await syncToSupabase();
        if (success) {
          showSuccessMessage("Sync completed successfully");
        }
      });

      // Test connection button
      checkConnectionBtn.addEventListener("click", async () => {
        if (!supabaseClient) {
          const url = supabaseUrlInput.value.trim();
          const key = supabaseKeyInput.value.trim();

          if (!url || !key) {
            showModal(supabaseConfigModal);
            return;
          }

          const success = await initSupabase(url, key);
          if (!success) {
            showErrorMessage("Failed to initialize Supabase");
            return;
          }
        }

        try {
          const { data, error } = await supabaseClient
            .from("collections")
            .select("*")
            .limit(1);
          if (error) throw error;
          showSuccessMessage("Connection successful!");
        } catch (error) {
          console.error("Connection test error:", error);
          showErrorMessage(
            "Connection failed. Please check your Supabase configuration."
          );
        }
      });

      // Save Supabase config
      saveSupabaseBtn.addEventListener("click", () => {
        const url = supabaseUrlInput.value.trim();
        const key = supabaseKeyInput.value.trim();

        if (!url || !key) {
          showErrorMessage("Please enter both URL and key");
          return;
        }

        supabaseConfig = { url, key };
        hideModal(supabaseConfigModal);

        // After config, try syncing again
        syncToSupabase();
      });

      // Cancel Supabase config
      cancelSupabaseBtn.addEventListener("click", () => {
        hideModal(supabaseConfigModal);
      });

      // Google Sign-in button
      googleSigninBtn.addEventListener("click", async () => {
        try {
          if (!supabaseClient) {
            showErrorMessage("Please configure Supabase first");
            return;
          }

          // Instead of using the regular OAuth flow, use the email-based passwordless sign-in
          const { error } = await supabaseClient.auth.signInWithOAuth({
            provider: "google",
            options: {
              skipBrowserRedirect: false, // Let the main window handle it
              redirectTo: window.location.origin + window.location.pathname,
              queryParams: {
                prompt: "select_account", // Always show account selection
              },
            },
          });

          if (error) {
            console.error("Google auth error:", error);
            showErrorMessage(
              "Failed to start Google authentication: " + error.message
            );
            return;
          }

          // The window will be redirected to Google, and then back with the token in the URL
          // No need for polling as the page will reload with auth data
        } catch (error) {
          console.error("Google sign-in error:", error);
          showErrorMessage("An error occurred during Google sign-in.");
        }
      });

      // Add a function to check URL for auth response on page load
      async function checkForAuthRedirect() {
        try {
          // Get the hash fragment from the URL
          const hash = window.location.hash;
          if (hash && hash.includes("access_token")) {
            // Parse the hash parameters
            const params = new URLSearchParams(hash.substring(1));
            const accessToken = params.get("access_token");

            if (accessToken) {
              // Auth was successful, notify the user
              hideModal(authModal);
              showSuccessMessage("Authentication successful!");

              // Try to sync after successful authentication
              setTimeout(() => {
                syncToSupabase().then((success) => {
                  if (success) {
                    showSuccessMessage("Data has been synced successfully.");
                  }
                });
              }, 1000);

              // Clear the hash from the URL to avoid issues on refresh
              if (history && history.replaceState) {
                history.replaceState(null, null, " ");
              } else {
                window.location.hash = "";
              }
            }
          }
        } catch (error) {
          console.error("Error checking auth redirect:", error);
        }
      }

      // Check for auth redirect when page loads
      window.addEventListener("load", checkForAuthRedirect);

      // Cancel auth
      cancelAuthBtn.addEventListener("click", () => {
        hideModal(authModal);
      });

      // Load saved Supabase config on startup
      window.addEventListener("load", () => {
        // Request Supabase config from plugin instead of using localStorage
        parent.postMessage(
          {
            pluginMessage: {
              type: "get-supabase-config",
            },
          },
          "*"
        );
      });

      // ============================================================
      // Message handling from Figma
      // ============================================================
      window.onmessage = (event) => {
        const msg = event.data.pluginMessage;

        if (!msg) return;

        switch (msg.type) {
          case "init":
            // Initialize with data from Figma
            if (msg.data && msg.data.collections) {
              console.log("Received plugin data:", msg.data);
              pluginData = msg.data;
              renderCollections();
            } else {
              console.error("Received invalid plugin data:", msg.data);
              // Set a default empty state if no valid data is received
              collectionsContainer.innerHTML = `<div class="empty-state">Could not load collections. Please restart the plugin.</div>`;
            }
            break;

          case "update":
            // Update data from Figma
            pluginData = msg.data;
            renderCollections();
            break;

          case "active-collection-changed":
            // Only update the active collection state without rerendering
            if (pluginData) {
              pluginData.activeCollectionId = msg.collectionId;

              // Just update the visual active state without full re-render
              document.querySelectorAll(".collection").forEach((coll) => {
                if (coll.classList.contains(`collection-${msg.collectionId}`)) {
                  coll.classList.add("active-collection");
                } else {
                  coll.classList.remove("active-collection");
                }
              });
            }
            break;

          case "supabase-config":
            // Received Supabase configuration from plugin
            if (msg.config && msg.config.url && msg.config.key) {
              supabaseUrlInput.value = msg.config.url;
              supabaseKeyInput.value = msg.config.key;
              initSupabase(msg.config.url, msg.config.key);
            }
            break;

          case "selection-data":
            // Received frame data for preset creation
            presetFramesContainer.innerHTML = "";

            // Store the original frame data for later use when saving the preset
            window.currentFrameData = msg.frames || [];

            if (msg.frames && msg.frames.length > 0) {
              msg.frames.forEach((frame) => {
                const frameGroup = document.createElement("div");
                frameGroup.classList.add("form-group", "frame-input-group");

                frameGroup.innerHTML = `
                <label>Frame: ${formatDimensions(
                  frame.width,
                  frame.height
                )}</label>
                <input type="text" class="frame-name-input" value="${
                  frame.name
                }" placeholder="Preset name">
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                  <input type="number" class="frame-width-input" value="${Math.round(
                    frame.width
                  )}" placeholder="Width">
                  <input type="number" class="frame-height-input" value="${Math.round(
                    frame.height
                  )}" placeholder="Height">
                </div>
              `;

                presetFramesContainer.appendChild(frameGroup);
              });

              showModal(createPresetModal);
            } else {
              showErrorMessage("No frames in selection");
            }
            break;
        }
      };

      // Function to set frame sizes based on aspect ratios
      function setFrameSizes() {
        // Get all preset cards
        const presetCards = document.querySelectorAll(".preset-card");

        presetCards.forEach((presetCard) => {
          // Find frame visual in this card
          const frameVisual = presetCard.querySelector(".frame-visual");
          if (!frameVisual) return;

          // Get preset ID and collection ID
          const presetId = presetCard.getAttribute("data-id");
          const collectionId = presetCard.getAttribute("data-collection");

          // Find preset data
          let width = 100;
          let height = 100;

          // Find this preset in the plugin data
          if (pluginData && pluginData.collections) {
            const collection = pluginData.collections.find(
              (c) => c.id === collectionId
            );
            if (collection) {
              const preset = collection.presets.find((p) => p.id === presetId);
              if (preset) {
                width = preset.width;
                height = preset.height;
              }
            }
          }

          // Adjust frame size based on aspect ratio but slightly smaller to avoid cropping
          const maxDimension = 20; // Keep the max dimension smaller to ensure no cropping

          if (width > height) {
            // Landscape
            const aspectRatio = width / height;
            const calculatedHeight = maxDimension / aspectRatio;
            frameVisual.style.width = maxDimension + "px";
            frameVisual.style.height = calculatedHeight + "px";
          } else if (height > width) {
            // Portrait
            const aspectRatio = height / width;
            const calculatedWidth = maxDimension / aspectRatio;
            frameVisual.style.height = maxDimension + "px";
            frameVisual.style.width = calculatedWidth + "px";
          } else {
            // Square
            frameVisual.style.width = maxDimension + "px";
            frameVisual.style.height = maxDimension + "px";
          }
        });
      }

      // Track expanded collections to preserve state during re-renders
      let expandedCollections = [];

      // Function to store current expanded state
      function saveExpandedState() {
        expandedCollections = [];
        document
          .querySelectorAll(".collection-content.expanded")
          .forEach((content) => {
            const collectionId = content.getAttribute("data-collection-id");
            if (collectionId) expandedCollections.push(collectionId);
          });
      }

      // Function to restore expanded state
      function restoreExpandedState() {
        expandedCollections.forEach((collectionId) => {
          const contentDiv = document.querySelector(
            `.collection-content[data-collection-id="${collectionId}"]`
          );
          const header = document.querySelector(
            `.collection-header[data-id="${collectionId}"]`
          );
          if (contentDiv) contentDiv.classList.add("expanded");
          if (header) {
            const arrow = header.querySelector(".arrow");
            if (arrow) arrow.classList.add("expanded");
          }
        });
      }

      // Function for smooth UI updates
      function smoothUpdate(callback) {
        const container = document.querySelector(".collections-container");

        // Only apply fade effect if container exists
        if (!container) {
          callback();
          return;
        }

        // Add a CSS class for the transition
        container.style.transition = "opacity 0.2s ease";
        container.style.opacity = "0.6";

        // Short timeout to let the transition happen
        setTimeout(() => {
          // Execute the update
          callback();

          // Restore opacity with a slight delay to ensure DOM is updated
          setTimeout(() => {
            container.style.opacity = "1";
          }, 50);
        }, 100);
      }

      // Apply frame sizing after collections are rendered
      const originalRenderCollections = renderCollections;
      renderCollections = function () {
        // Save expanded state before re-rendering
        saveExpandedState();

        // Call original render function with smooth transition
        smoothUpdate(() => {
          originalRenderCollections.apply(this, arguments);
          // Restore expanded state immediately after rendering
          restoreExpandedState();
          // Apply frame sizing after restoring state
          setFrameSizes();
        });
      };

      // Also apply frame sizing when the UI receives updates
      window.addEventListener("message", function (event) {
        if (
          event.data.pluginMessage &&
          event.data.pluginMessage.type === "update"
        ) {
          // Apply frame sizing after a short delay to ensure DOM is updated
          setTimeout(setFrameSizes, 50);
        }
      });

      // Function to generate a short share ID (for display purposes)
      function generateShareId() {
        // Generate a 6-digit code with letters and numbers
        const characters = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Excluding similar looking characters
        let result = "";
        for (let i = 0; i < 6; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * characters.length)
          );
        }
        return result;
      }

      // Function to share a collection
      async function shareCollection(collectionId) {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          return;
        }

        try {
          // Find the collection
          const collection = pluginData.collections.find(
            (c) => c.id === collectionId
          );
          if (!collection) {
            showErrorMessage("Collection not found");
            return;
          }

          // Create a new entry in the shared_collections table
          const { data: sharedCollection, error } = await supabaseClient
            .from("shared_collections")
            .insert({
              collection_id: collectionId,
              name: collection.name,
              presets: collection.presets,
            })
            .select("share_id")
            .single();

          if (error) {
            console.error("Error sharing collection:", error);
            showErrorMessage("Error sharing collection: " + error.message);
            return;
          }

          // Get the share_id from the response
          const shareId = sharedCollection.share_id;

          // Show the full share ID (not truncated) to ensure exact matching when importing
          shareLink.textContent = shareId;
          showModal(shareCollectionModal);
        } catch (error) {
          console.error("Share error:", error);
          showErrorMessage("Failed to share collection: " + error.message);
        }
      }

      // Add non-blocking notification functions
      function showErrorMessage(message) {
        // Create notification element if it doesn't exist
        let notification = document.getElementById("error-notification");
        if (!notification) {
          notification = document.createElement("div");
          notification.id = "error-notification";
          notification.style.position = "fixed";
          notification.style.bottom = "20px";
          notification.style.left = "50%";
          notification.style.transform = "translateX(-50%)";
          notification.style.backgroundColor = "rgba(255, 59, 48, 0.9)";
          notification.style.color = "white";
          notification.style.padding = "8px 16px";
          notification.style.borderRadius = "4px";
          notification.style.fontSize = "12px";
          notification.style.zIndex = "2000";
          notification.style.maxWidth = "90%";
          notification.style.textAlign = "center";
          notification.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
          document.body.appendChild(notification);
        }

        // Set message and show
        notification.textContent = message;
        notification.style.display = "block";

        // Auto-hide after 3 seconds
        setTimeout(() => {
          notification.style.display = "none";
        }, 3000);
      }

      function showSuccessMessage(message) {
        // Create notification element if it doesn't exist
        let notification = document.getElementById("success-notification");
        if (!notification) {
          notification = document.createElement("div");
          notification.id = "success-notification";
          notification.style.position = "fixed";
          notification.style.bottom = "20px";
          notification.style.left = "50%";
          notification.style.transform = "translateX(-50%)";
          notification.style.backgroundColor = "rgba(48, 209, 88, 0.9)";
          notification.style.color = "white";
          notification.style.padding = "8px 16px";
          notification.style.borderRadius = "4px";
          notification.style.fontSize = "12px";
          notification.style.zIndex = "2000";
          notification.style.maxWidth = "90%";
          notification.style.textAlign = "center";
          notification.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
          document.body.appendChild(notification);
        }

        // Set message and show
        notification.textContent = message;
        notification.style.display = "block";

        // Auto-hide after 3 seconds
        setTimeout(() => {
          notification.style.display = "none";
        }, 3000);
      }

      // Signal to Figma that the UI is ready
      parent.postMessage({ pluginMessage: { type: "ui-ready" } }, "*");
    </script>
  </body>
</html>
