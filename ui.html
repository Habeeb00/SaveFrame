<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frame Presets</title>
    <style>
      :root {
        /* Light Mode Variables */
        --primary-color: #0d99ff;
        --first-color: #2c2c2c;
        --second-color: #7f7f7f;
        --third-color: #b3b3b3;
        --heading-color: #161616;
        --secondary-color: #888888;
        --bg-color: #ffffff;
        --text-color: #333333;
        --border-color: #e0e0e0;
        --active-color: #d4d4d4;
        --hover-color: #f0f0f0;
        --accent-color: #0d99ff;
        --star-color: rgb(243, 243, 39);
        --shadow-color: rgba(0, 0, 0, 0.1);
        --figma-bg: #f5f5f5;
        --figma-text: #333333;
        --figma-secondary: #7f7f7f;
        --figma-border: #e5e5e5;
        --figma-hover: #e8e8e8;
        --figma-blue: #18a0fb;
        --figma-blue-hover: #0d8de3;
        --tooltip-delay: 600ms;
        --error-color: #ff3b30;
        --button-color: #2c2c2e;
        --collection-header-bg: #2c2c2e;
      }

      :root {
        /* Common transition variables */
        --transition-speed: 0.3s;
        --transition-function: ease;
      }

      [data-theme="dark"] {
        /* Dark Mode Variables */
        --heading-color: f5f5f5;
        --primary-color: #0a84ff;
        --third-color: #8e8e93;
        --text-color: #8e8e93;
        --text-primary: #8e8e93;
        --text-secondary: #aeaeb2;
        --bg-color: #1c1c1e;
        --star-color: #aeaeb2;
        --sidebar-bg: #2c2c2e;
        --border-color: #38383a;
        --hover-color: #3a3a3c;
        --active-color: #848484;
        --danger-color: #ff4530;
        --shadow-color: rgba(0, 0, 0, 0.3);
        --button-color: #2c2c2e;
        --collection-header-bg: #2c2c2e;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        font-size: 10px;
        transition-property: background-color, border-color, color, opacity,
          transform, max-height;
        transition-duration: var(--transition-speed);
        transition-timing-function: var(--transition-function);
        max-width: 100%; /* Prevent content from overflowing horizontally */
      }

      /* Force content to stay within bounds */
      html,
      body {
        width: 100%;
        max-width: 100vw;
        overflow-x: hidden !important; /* Force no horizontal scroll */
        overscroll-behavior: none;
      }

      .sidebar {
        width: 100% !important; /* Ensure sidebar takes exact width */
        max-width: 100%; /* Prevent sidebar overflow */
        overflow-x: hidden !important; /* Force no horizontal scroll in sidebar */
      }

      /* Fix collections container to prevent overflow */
      .collections-container {
        width: 100%;
        max-width: 100%;
        overflow-x: hidden !important;
        padding-right: 0;
        box-sizing: border-box;
      }

      /* Ensure preset cards don't overflow */
      .preset-card {
        width: 100%;
        max-width: 100%;
        overflow-x: hidden !important;
        box-sizing: border-box;
      }
      .header {
        color: var(--heading-color);
      }
      body {
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        margin: 0;
        padding: 0;
        font-size: 12px;
        color: var(--figma-text);
        background-color: var(--figma-bg);
        overflow-y: auto;
        overflow-x: hidden !important;
        overscroll-behavior: none;
      }

      /* Remove ALL scrollbars for horizontal scrolling */
      ::-webkit-scrollbar:horizontal,
      ::-webkit-scrollbar-horizontal {
        width: 0 !important;
        height: 0 !important;
        display: none !important;
      }

      /* Ensure no horizontal scrolling in Figma's Chrome-based environment */
      html,
      body {
        overflow-x: hidden;
        width: 100%;
      }

      .collections-container {
        overflow-x: hidden;
      }

      /* Tooltip styles */
      [data-tooltip] {
        position: relative;
      }

      [data-tooltip]::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background-color: #333;
        color: white;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        transition-delay: 0ms;
        pointer-events: none;
        z-index: 1000;
      }

      [data-tooltip]:hover::after {
        opacity: 1;
        visibility: visible;
        transition-delay: var(--tooltip-delay);
      }

      /* Stylish scrollbar */
      ::-webkit-scrollbar {
        width: 4px;
        height: 4px;
      }

      ::-webkit-scrollbar-track {
        background: transparent;
        margin: 4px 0;
      }

      ::-webkit-scrollbar-thumb {
        background: rgba(150, 150, 150, 0.3);
        border-radius: 10px;
        transition: background 0.3s ease;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: rgba(150, 150, 150, 0.5);
      }

      /* Dark mode scrollbar */
      [data-theme="dark"]::-webkit-scrollbar-thumb {
        background: rgba(200, 200, 200, 0.2);
      }

      [data-theme="dark"]::-webkit-scrollbar-thumb:hover {
        background: rgba(200, 200, 200, 0.4);
      }

      body {
        background-color: var(--bg-color);
        color: var(--text-secondary);
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
        transition: background-color 0.3s, color 0.3s;
        font-size: 11px;
        overflow-x: hidden;
        overflow-y: auto;
        overscroll-behavior-x: none;
      }
      ::-webkit-scrollbar-horizontal {
        display: none;
      }

      .sidebar {
        background-color: var(--sidebar-bg);
        color: var(--text-primary);
        border-right: 1px solid transparent;
        height: 100vh;
        overflow-y: auto;
        width: 100%;
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
        /* More subtle appearance */
        backdrop-filter: blur(5px);
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
      }

      /* Subtler dark mode sidebar */
      [data-theme="dark"] .sidebar {
        background-color: rgba(44, 44, 46, 0.9);
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
      }

      /* Main scrollable container */
      .main {
        padding: 0;
        flex: 1;
        overflow-y: auto;
        background-color: white;
      }

      button {
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--text-color);
        padding: 4px 8px;
        border-radius: 2px;
        display: flex;
        align-items: center;
        transition: background-color 0.2s;
        font-size: 10px;
      }

      button:hover {
        background-color: var(--figma-hover);
      }

      button.primary {
        background-color: var(--figma-blue);
        color: white;
        border-color: var(--figma-blue);
      }

      button.primary:hover {
        background-color: var(--figma-blue-hover);
        border-color: var(--figma-blue-hover);
      }

      button.danger {
        color: var(--danger-color);
      }

      button.danger:hover {
        background-color: rgba(242, 72, 34, 0.1);
      }

      button svg {
        margin-right: 4px;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-color);
      }

      .toolbar {
        display: flex;
        justify-content: space-between;
        padding: 6px 12px;
        border-bottom: 1px solid var(--border-color);
      }

      .toolbar-buttons {
        display: flex;
        gap: 8px;
      }

      .collection-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 4px 8px; /* Increased padding from 2px to 4px to add more space */
        border-radius: 2px;
        margin-bottom: 0;
        transition: background-color 0.2s ease;
        border-bottom: 0px solid rgba(0, 0, 0, 0.1);
      }
      .drag-handle {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 6px;
        cursor: move;
        opacity: 0.4;
        transition: opacity 0.2s ease;
        align-self: center; /* Ensure vertical centering within flex parent */
      }

      .drag-handle:hover {
        background-color: var(--hover-color);
        border-radius: 50%;
        transition: background-color 0.2s ease;
      }

      .collection-header:hover .drag-handle {
        opacity: 0.8;
      }

      .collection-name {
        margin-left: 4px;
        flex: 1;
      }

      .collection-header.dragging {
        opacity: 0.6;
        background-color: var(--figma-color-bg-hover);
      }

      .collection-header.drag-over {
        border-top: 2px solid var(--figma-color-border-brand);
      }

      .active-collection .collection-header {
        background-color: var(--hover-color);
        color: var(--text-color);
      }

      .active-collection .collection-header .delete-collection-btn,
      .active-collection .collection-header .share-collection-btn,
      .active-collection .collection-header .drag-handle {
        opacity: 100%;
        visibility: visible;
      }

      /* Add header right container for buttons and arrow */
      .collection-header-right {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .collection-name {
        display: flex;
        align-items: center;
        font-weight: 500;
        flex-grow: 1; /* Take up available space */
      }

      .collection-header:hover {
        background-color: var(--hover-color);
      }

      /* Style for collection actions */
      .collection-actions {
        display: flex;
        gap: 8px;
        transition: opacity 0.2s ease;
      }

      /* Make delete button more visible */
      .delete-collection-btn,
      .share-collection-btn {
        opacity: 30%;
      }

      .delete-collection-btn:hover,
      .share-collection-btn:hover {
        opacity: 100%;
      }

      .collection-header:hover .delete-collection-btn,
      .collection-header:hover .share-collection-btn,
      .collection-header:hover .drag-handle,
      .active-collection .collection-header .delete-collection-btn,
      .active-collection .collection-header .share-collection-btn,
      .active-collection .collection-header .drag-handle {
        opacity: 1 !important;
      }

      .collection-header .arrow {
        transition: transform 0.3s, color 0.2s;
        margin-left: 4px;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        font-weight: bold;
      }

      .collection-header .arrow:before {
        content: "▶";
        display: block;
        font-size: 8px; /* Smaller triangle */
        transform: scale(1); /* Remove scaling to make it smaller */
      }

      .collection-header .arrow:hover {
        color: var(--primary-color); /* Light up on hover */
      }

      .collection-header .arrow.expanded {
        transform: rotate(90deg);
      }

      .collection-dimensions {
        margin-left: auto;
        font-size: 9px;
        color: var(--secondary-color);
        margin-right: 8px;
      }

      .collection-content {
        overflow: hidden;
        max-height: 0;
        visibility: hidden; /* Use visibility instead of opacity */
        transition: max-height 0.3s var(--transition-function),
          visibility 0s linear 0.3s; /* Delay visibility change */
        margin: 0;
        padding: 0;
      }

      /* Prevent favorites from visually re-expanding due to layout reflow */
      .collection-content[data-collection-id="favorites"] {
        transition: none !important;
      }

      .collection-content.expanded {
        max-height: 2000px;
        visibility: visible; /* Use visibility instead of opacity */
        transition: max-height 0.3s var(--transition-function),
          visibility 0s linear 0s; /* No delay for visibility */
        border-top: none;
      }
      c .presets-list {
        display: flex;
        flex-direction: column;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }

      .preset-card {
        display: grid;
        grid-template-columns: 36px minmax(0, 1fr) auto;
        padding: 1px 2px; /* Reduced padding for more compact UI */
        cursor: pointer;
        position: relative;
        align-items: center;
        transition: background-color 0.2s, transform 0.3s ease,
          opacity 0.3s ease;
        opacity: 1;
        transform: translateX(0);
        height: auto;
        overflow: hidden;
        border: none;
        column-gap: 0px;
      }

      /* Create animation classes for entry/exit */
      .preset-card-removing {
        opacity: 0;
        transform: translateX(-20px);
        height: 0;
        padding: 0;
        margin: 0;
        border: none;
      }

      /* Make frame preview containers completely invisible in both dark and light mode */
      .preset-preview {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        position: relative;
        flex-shrink: 0;
        background-color: transparent !important;
        padding: 0;
        margin: 0;
        border: none;
        box-shadow: none;
        overflow: visible;
      }

      .preset-preview svg {
        background: transparent;
        overflow: visible;
      }

      /* Light theme frame colors - exact match to Figma screenshots */
      .frame-rect-fill {
        fill: #ececec;
        stroke: #c7c7c7;
        stroke-width: 1px;
      }

      /* Dark theme frame colors - exact match to Figma screenshots */
      [data-theme="dark"] .frame-rect-fill {
        fill: #474747;
        stroke: #5e5e5e;
        stroke-width: 1px;
      }

      .frame-visual {
        border: 1px solid #ddd;
        background-color: white;
        border-radius: 3px;
        /* Visual size is dynamic based on aspect ratio but contained in fixed width parent */
        flex-shrink: 0;
        overflow: hidden;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }

      /* Dark mode adjustments for better readability */
      [data-theme="dark"] .frame-visual {
        border: 1px solid #555;
        background-color: #2a2a2a;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      [data-theme="dark"] .preset-name,
      [data-theme="dark"] .preset-dimensions {
        color: rgba(255, 255, 255, 0.9);
      }

      [data-theme="dark"] .preset-card:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }

      [data-theme="dark"] .collection-header {
        background-color: #252526;
        border-bottom: 1px solid #000000;
      }

      [data-theme="dark"] .active-collection .collection-header {
        background-color: #4f4e4e;
      }

      [data-theme="dark"] .collection-name {
        color:#f5f5f5;
      }

      [data-theme="dark"] button {
        color: #eeeeee;
      }

      [data-theme="dark"] button:hover {
        background-color: transparent;
        box-shadow: none;
      }

      [data-theme="dark"] .favorite-btn.active svg {
        fill: #ffcc33;
        stroke: #ffcc33;
      }

      [data-theme="dark"] .new-collection-btn,
      [data-theme="dark"] .import-btn {
        background-color: #3a3a3c;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 6px 12px;
        color: #ffffff;
        transition: background-color 0.2s ease, border-color 0.2s ease;
      }

      [data-theme="dark"] .new-collection-btn:hover,
      [data-theme="dark"] .import-btn:hover {
        background-color: #4a4a4c;
        border-color: #666;
      }

      .preset-name {
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 90px; /* Fixed max width instead of percentage */
        margin-left: 4px; /* Reduced left margin */
      }

      .preset-info {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        overflow: hidden;
        min-width: 0; /* Important for text truncation to work properly */
      }

      .preset-dimensions-row {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 6px;
        margin-left: auto;
        flex-shrink: 0;
      }

      .preset-dimensions {
        font-size: 10px;
        color: var(--text-secondary);
      }

      .preset-actions {
        display: flex;
        align-items: center;
        gap: 2px;
        margin-left: 2px;
      }

      .favorite-btn,
      .delete-preset-btn,
      .preset-actions button {
        border: none;
        background: none;
        color: var(--secondary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 5px;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.1s ease;
        width: 25px;
        height: 25px;
        position: relative;
        margin-right: 1px;
      }
      .collection-actions button {
        border: none;
        background: none;
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 5px;
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        width: 25px;
        height: 25px;
        position: relative;
        margin-right: 3px;
      }

      .preset-actions button svg,
      .collection-actions button svg {
        width: 16px;
        height: 16px;
      }

      .favorite-btn {
        color: var(--text-secondary);
        padding: 0;
        margin: 0 4px;
        border-radius: 0;
        background: none;
        box-shadow: none;
        min-width: auto;
        min-height: auto;
        width: 17px;
        height: 17px;
        flex-shrink: 0;
        opacity: 10%;
      }

      .favorite-btn.active {
        color: var(--primary-color);
        background: none;
        box-shadow: none;
      }

      .favorite-btn svg {
        stroke: currentColor;
        stroke-width: 1.5px;
      }

      .delete-preset-btn:hover {
        background-color: var(--hover-color);
      }

      .favorite-btn:hover {
        background-color: transparent;
      }

      .delete-preset-btn {
        color: var(--text-secondary);
      }

      .delete-preset-btn:hover {
        color: var(--error-color);
      }

      .preset-card:hover {
        background-color: var(--hover-color);
      }

      .preset-preview {
        background-color: var(--active-color);
        border-radius: 2px;
        margin-bottom: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 6px;
        aspect-ratio: 16/9;
        overflow: hidden;
        margin-left: 4px;
      }

      .frame-visual {
        margin-bottom: 4px;
        box-shadow: 0 1px 3px var(--shadow-color);
      }

      .frame-dimensions {
        font-size: 9px;
        color: var(--text-primary);
        text-align: center;
      }

      .preset-info {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        margin-left: 6px;
        width: 100%;
      }

      .preset-dimensions {
        font-size: 9px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-right: 9px;
        flex: 1;
      }

      .favorite-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .preset-card:hover .favorite-btn {
        opacity: 1;
      }

      .favorite-btn.active {
        opacity: 1;
        color: var(--star-color);
      }

      .status-bar {
        border-top: 0.3px solid var(--border-color);
        padding: 8px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: auto;
      }

      .sync-status {
        font-size: 10px;
        color: var(--secondary-color);
      }

      .theme-toggle {
        cursor: pointer;
        color: var(--figma-secondary);
        padding: 4px;
      }

      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        backdrop-filter: blur(2px);
      }

      .modal.active {
        opacity: 1;
        pointer-events: auto;
      }

      .modal-content {
        background-color: var(--bg-color);
        border-radius: 6px;
        padding: 0;
        width: 90%;
        max-width: 320px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        max-height: 80vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transform: translateY(10px);
        transition: transform 0.2s ease;
      }

      .modal.active .modal-content {
        transform: translateY(0);
      }

      .modal-header {
        padding: 16px;
        font-weight: 500;
        border-bottom: 1px solid var(--border-color);
        font-size: 13px;
      }

      .modal-body {
        padding: 16px;
        overflow-y: auto;
      }

      #preset-frames-container {
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 4px;
      }

      .input-hint {
        font-size: 11px;
        color: var(--secondary-color);
        margin-top: 4px;
      }

      [data-theme="dark"] .input-hint {
        color: var(--text-secondary);
      }

      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 0;
        padding: 12px 16px;
        border-top: 1px solid var(--border-color);
        background-color: var(--active-color);
      }

      [data-theme="dark"] .form-actions {
        background-color: #2a2a2c;
      }

      .favorites-section {
        border-bottom: 1px solid var(--border-color);
        max-height: 30vh;
        overflow-y: auto;
      }

      .empty-state {
        padding: 16px;
        text-align: center;
        color: var(--secondary-color);
        font-size: 11px;
      }

      .share-modal .share-link {
        background-color: var(--active-color);
        padding: 10px;
        border-radius: 4px;
        font-family: monospace;
        margin: 10px 0;
        word-break: break-all;
      }

      .copy-btn {
        margin-top: 8px;
        width: 100%;
        justify-content: center;
      }

      /* Loading animation */
      .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
      }

      .loading-spinner {
        border: 2px solid var(--border-color);
        border-top: 2px solid var(--accent-color);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
      }

      /* Figma-style notification system */
      .notification {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 11px;
        z-index: 2000;
        max-width: 90%;
        text-align: center;
        display: flex;
        align-items: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }

      .notification.show {
        opacity: 1;
        pointer-events: all;
      }

      .notification-icon {
        margin-right: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .notification-error {
        background-color: #f5f5f5;
        color: #333333;
        border-left: 3px solid #f24822;
      }

      .notification-success {
        background-color: #f5f5f5;
        color: #333333;
        border-left: 3px solid #14ae5c;
      }

      .notification-warning {
        background-color: #f5f5f5;
        color: #333333;
        border-left: 3px solid #ffbd44;
      }

      /* Dark mode notifications */
      [data-theme="dark"] .notification {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      [data-theme="dark"] .notification-error,
      [data-theme="dark"] .notification-success,
      [data-theme="dark"] .notification-warning {
        background-color: #2c2c2e;
        color: #ffffff;
      }

      .frame-input-group {
        background-color: var(--bg-color);
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 12px;
        border: 1px solid var(--border-color);
      }

      .frame-input-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        font-size: 11px;
        color: var(--secondary-color);
      }

      .frame-input-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 2px;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-size: 11px;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        outline: none;
      }

      .frame-input-group input:focus {
        border-color: var(--figma-blue);
        box-shadow: 0 0 0 1px var(--figma-blue);
      }

      .frame-dimensions-row {
        display: flex;
        gap: 6px;
      }

      .dimension-group {
        position: relative;
        flex: 1;
        margin-right: 2px;
      }

      .dimension-group input {
        padding-right: 24px;
      }

      .dimension-group label {
        position: absolute;
        right: 8px;
        top: 8px;
        color: var(--secondary-color);
        font-size: 10px;
        pointer-events: none;
      }

      .frame-preview {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px 0;
      }

      .frame-preview-visual {
        border: 1px solid var(--border-color);
        background-color: #fff;
        border-radius: 2px;
        position: relative;
      }

      [data-theme="dark"] .frame-preview-visual {
        background-color: #333;
        border-color: #444;
      }

      #preset-frames-container {
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 4px;
      }

      .input-hint {
        font-size: 11px;
        color: var(--secondary-color);
        margin-top: 4px;
      }

      .collection {
        border-bottom: 1px solid var(--border-color);
        border-top: none;
        margin: 0;
        padding: 0;
      }

      /* Remove the last border to avoid double borders */
      .collection:last-child {
        border-bottom: none;
      }

      .collections-container {
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        width: 100%;
        /* Ensure no gaps between collections */
        gap: 0;
      }

      .collection-favorites .preset-dimensions {
        padding-right: 8px;
      }

      /* Remove bottom slider */
      body {
        overflow-x: hidden; /* Prevent horizontal scrolling */
        overflow-y: auto; /* Allow vertical scrolling */
        overscroll-behavior-x: none; /* Prevent horizontal overscroll */
      }

      /* Hide horizontal scrollbar */
      ::-webkit-scrollbar-horizontal {
        display: none;
      }
    </style>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  </head>
  <body data-theme="dark">
    <!-- ( refresh button temp) -->
    <button
      id="refresh-ui-btn"
      style="
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 9999;
        background: #ffecb3;
        color: #333;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
      "
    >
      Refresh UI
    </button>
    <script>
      document
        .getElementById("refresh-ui-btn")
        .addEventListener("click", function () {
          if (typeof renderCollections === "function") {
            renderCollections();
          }
        });
    </script>
    <div class="sidebar">
      <div class="header">
        <h3>Frame Presets</h3>
        <div>
          <button
            id="create-preset-btn"
            class="primary"
            data-tooltip="Create preset from selected frame"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 1V11M1 6H11"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
              />
            </svg>
            Save Frame
          </button>
        </div>
      </div>

      <div class="toolbar">
        <div class="toolbar-buttons">
          <button
            id="new-collection-btn"
            data-tooltip="Create a new collection"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 1V11M1 6H11"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
              />
            </svg>
            New Collection
          </button>
          <button
            id="import-btn"
            data-tooltip="Import a collection from another user"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1 9L1 10C1 10.5523 1.44772 11 2 11L10 11C10.5523 11 11 10.5523 11 10L11 9M6 8L6 1M6 8L3.5 5.5M6 8L8.5 5.5"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Import
          </button>
          <button
            id="check-connection-btn"
            data-tooltip="Verify Supabase connection"
            style="margin-left: 8px"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 12 12"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M10.5 6C10.5 8.48528 8.48528 10.5 6 10.5C3.51472 10.5 1.5 8.48528 1.5 6C1.5 3.51472 3.51472 1.5 6 1.5C8.48528 1.5 10.5 3.51472 10.5 6Z"
                stroke="currentColor"
                stroke-width="1.5"
              />
              <path
                d="M4 6L5.25 7.25L8 4.5"
                stroke="currentColor"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Test Connection
          </button>
        </div>
        <button
          id="sync-btn"
          data-tooltip="Sync your collections with Supabase"
        >
          <svg
            width="12"
            height="12"
            viewBox="0 0 12 12"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M1 5.5C1 3.29086 2.79086 1.5 5 1.5C6.48052 1.5 7.77308 2.30205 8.46922 3.5M11 6.5C11 8.70914 9.20914 10.5 7 10.5C5.51948 10.5 4.22692 9.69795 3.53078 8.5"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
            />
            <path
              d="M9.5 1.5L8.5 3.5L10.5 3.5M2.5 10.5L3.5 8.5L1.5 8.5"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          Sync
        </button>
      </div>

      <div class="collections-container">
        <!-- Collections will be added here dynamically -->
        <div class="loading">
          <div class="loading-spinner"></div>
        </div>
      </div>

      <div class="status-bar">
        <div class="sync-status">Last synced: Never</div>
        <div class="theme-toggle" id="theme-toggle">
          <svg
            width="14"
            height="14"
            viewBox="0 0 14 14"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M7 1.5V1M7 13V12.5M12.5 7H13M1 7H1.5M10.8995 3.1005L11.2497 2.7503M2.7503 11.2497L3.1005 10.8995M10.8995 10.8995L11.2497 11.2497M2.7503 2.7503L3.1005 3.1005M9.5 7C9.5 8.38071 8.38071 9.5 7 9.5C5.61929 9.5 4.5 8.38071 4.5 7C4.5 5.61929 5.61929 4.5 7 4.5C8.38071 4.5 9.5 5.61929 9.5 7Z"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
            />
          </svg>
        </div>
      </div>
    </div>
    <!-- End of sidebar -->

    <!-- Create Collection Modal -->
    <div class="modal" id="new-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Create New Collection</div>
        <div class="modal-body">
          <div class="form-group">
            <label for="collection-name">Collection Name</label>
            <input
              type="text"
              id="collection-name"
              placeholder="e.g., Web Banners"
              autofocus
            />
            <div class="input-hint">
              Create a collection to organize your frame presets
            </div>
          </div>
        </div>
        <div class="form-actions">
          <button id="cancel-collection-btn">Cancel</button>
          <button id="save-collection-btn" class="primary">Create</button>
        </div>
      </div>
    </div>

    <!-- Create Preset Modal -->
    <div class="modal" id="create-preset-modal">
      <div class="modal-content">
        <div class="modal-header">Save Frame Preset</div>
        <div class="modal-body">
          <div id="preset-frames-container">
            <!-- Frame inputs will be added here dynamically -->
          </div>
        </div>
        <div class="form-actions">
          <button id="cancel-preset-btn">Cancel</button>
          <button id="save-preset-btn" class="primary">Save</button>
        </div>
      </div>
    </div>

    <!-- Share Collection Modal -->
    <div class="modal share-modal" id="share-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Share Collection</div>
        <div class="modal-body">
          <p>Share this ID with others to let them import your collection:</p>
          <div class="share-link" id="share-link">...</div>
        </div>
        <div class="form-actions">
          <button id="copy-share-link" class="copy-btn primary">
            Copy to Clipboard
          </button>
          <button id="close-share-modal-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- Import Collection Modal -->
    <div class="modal" id="import-collection-modal">
      <div class="modal-content">
        <div class="modal-header">Import Collection</div>
        <div class="modal-body">
          <div class="form-group">
            <label for="import-id">Collection ID</label>
            <input
              type="text"
              id="import-id"
              placeholder="Paste collection ID here"
              autofocus
            />
            <div class="input-hint">Enter a collection ID shared with you</div>
          </div>
        </div>
        <div class="form-actions">
          <button id="cancel-import-btn">Cancel</button>
          <button id="import-collection-btn" class="primary">Import</button>
        </div>
      </div>
    </div>

    <!-- Supabase Configuration Modal -->
    <div class="modal" id="supabase-config-modal">
      <div class="modal-content">
        <div class="modal-header">Supabase Configuration</div>
        <div class="modal-body">
          <div class="form-group">
            <label for="supabase-url">Supabase URL</label>
            <input
              type="text"
              id="supabase-url"
              placeholder="https://your-project.supabase.co"
            />
          </div>
          <div class="form-group">
            <label for="supabase-key">Supabase Anon Key</label>
            <input type="text" id="supabase-key" placeholder="your-anon-key" />
          </div>
        </div>
        <div class="form-actions">
          <button id="cancel-supabase-btn">Cancel</button>
          <button id="save-supabase-btn" class="primary">Save</button>
        </div>
      </div>
    </div>

    <!-- Authentication Modal -->
    <div class="modal" id="auth-modal">
      <div class="modal-content">
        <div class="modal-header">Authentication Required</div>
        <div class="modal-body">
          <div id="auth-form-container">
            <p class="auth-message">Please sign in to sync your collections</p>
            <div class="oauth-buttons">
              <button id="google-signin-btn" class="google-button">
                <img
                  src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Google_%22G%22_Logo.svg/512px-Google_%22G%22_Logo.svg.png"
                  alt="Google"
                  style="width: 16px; height: 16px; margin-right: 8px"
                />
                Sign in with Google
              </button>
            </div>
          </div>
        </div>
        <div class="form-actions">
          <button id="cancel-auth-btn">Cancel</button>
        </div>
      </div>
    </div>

    <script>
      // ============================================================
      // Global state
      // ============================================================
      let pluginData = {
        collections: [],
        activeCollectionId: null,
        lastSyncedAt: null,
      };

      let theme = "light";
      let supabaseConfig = {
        url: null,
        key: null,
      };

      // Supabase client initialization
      let supabaseClient = null;

      async function initSupabase(url, key) {
        try {
          supabaseClient = supabase.createClient(url, key, {
            auth: {
              autoRefreshToken: true,
              persistSession: true,
              detectSessionInUrl: true,
            },
          });
          return true;
        } catch (error) {
          console.error("Failed to initialize Supabase:", error);
          return false;
        }
      }

      // ============================================================
      // DOM Elements
      // ============================================================
      // Global variables
      const collectionsContainer = document.querySelector(
        ".collections-container"
      );
      const themeToggle = document.getElementById("theme-toggle");
      const syncBtn = document.getElementById("sync-btn");
      const createPresetBtn = document.getElementById("create-preset-btn");
      const newCollectionBtn = document.getElementById("new-collection-btn");
      const importBtn = document.getElementById("import-btn");
      const checkConnectionBtn = document.getElementById(
        "check-connection-btn"
      );

      // Modal elements
      const newCollectionModal = document.getElementById(
        "new-collection-modal"
      );
      const collectionNameInput = document.getElementById("collection-name");
      const saveCollectionBtn = document.getElementById("save-collection-btn");
      const cancelCollectionBtn = document.getElementById(
        "cancel-collection-btn"
      );

      const createPresetModal = document.getElementById("create-preset-modal");
      const presetFramesContainer = document.getElementById(
        "preset-frames-container"
      );
      const savePresetBtn = document.getElementById("save-preset-btn");
      const cancelPresetBtn = document.getElementById("cancel-preset-btn");

      const shareCollectionModal = document.getElementById(
        "share-collection-modal"
      );
      const shareLink = document.getElementById("share-link");
      const copyShareLinkBtn = document.getElementById("copy-share-link");
      const closeShareModalBtn = document.getElementById(
        "close-share-modal-btn"
      );

      const importCollectionModal = document.getElementById(
        "import-collection-modal"
      );
      const importIdInput = document.getElementById("import-id");
      const importCollectionBtn = document.getElementById(
        "import-collection-btn"
      );
      const cancelImportBtn = document.getElementById("cancel-import-btn");

      const supabaseConfigModal = document.getElementById(
        "supabase-config-modal"
      );
      const supabaseUrlInput = document.getElementById("supabase-url");
      const supabaseKeyInput = document.getElementById("supabase-key");
      const saveSupabaseBtn = document.getElementById("save-supabase-btn");
      const cancelSupabaseBtn = document.getElementById("cancel-supabase-btn");

      // Auth Modal elements
      const authModal = document.getElementById("auth-modal");
      const googleSigninBtn = document.getElementById("google-signin-btn");
      const cancelAuthBtn = document.getElementById("cancel-auth-btn");

      // ============================================================
      // Helper Functions
      // ============================================================

      // Show a modal
      function showModal(modal) {
        modal.classList.add("active");
      }

      // Hide a modal
      function hideModal(modal) {
        modal.classList.remove("active");
      }

      // Generate a unique ID
      function generateId() {
        return Date.now().toString();
      }

      // Toggle collection expansion
      function toggleCollection(collectionId) {
        const arrow = document.querySelector(
          `.collection-${collectionId} .arrow`
        );
        const content = document.querySelector(
          `.collection-content[data-collection-id="${collectionId}"]`
        );

        arrow.classList.toggle("expanded");
        content.classList.toggle("expanded");
      }

      // Toggle theme
      function toggleTheme() {
        if (theme === "light") {
          document.body.setAttribute("data-theme", "dark");
          theme = "dark";
        } else {
          document.body.removeAttribute("data-theme");
          theme = "light";
        }

        // Save theme preference
        parent.postMessage(
          { pluginMessage: { type: "theme-preference", theme } },
          "*"
        );
      }

      // Format dimensions for display
      function formatDimensions(width, height) {
        return `${Math.round(width)} × ${Math.round(height)}`;
      }

      // Calculate scale factor for frames to ensure consistent visual size
      function calculateScaleFactor(width, height) {
        const targetSize = 50; // Our target frame size (50x50px)
        const maxDimension = Math.max(width, height);

        // Scale down large frames
        if (maxDimension > targetSize) {
          return targetSize / maxDimension;
        }
        // Scale up small frames
        else if (maxDimension < targetSize) {
          return targetSize / maxDimension;
        }
        // Keep 1:1 if already at target size
        return 1;
      }

      // Supabase Integration
      async function setupSupabase() {
        if (!supabaseConfig.url || !supabaseConfig.key) {
          showModal(supabaseConfigModal);
          return false;
        }
        return true;
      }

      // Create Supabase client
      function createSupabaseClient() {
        // This is a simplified version since we can't include the actual Supabase client library
        // In a real implementation, you would use the Supabase JS client
        return {
          from: (table) => {
            return {
              select: () => Promise.resolve([]),
              insert: (data) => Promise.resolve(data),
              update: (data) => Promise.resolve(data),
              delete: () => Promise.resolve(true),
              eq: () => this,
            };
          },
          auth: {
            getSession: () => Promise.resolve(null),
          },
        };
      }

      // Sync data to Supabase
      async function syncToSupabase() {
        if (!supabaseClient) {
          const url = supabaseUrlInput.value.trim();
          const key = supabaseKeyInput.value.trim();

          if (!url || !key) {
            showModal(supabaseConfigModal);
            return false;
          }

          const success = await initSupabase(url, key);
          if (!success) {
            showErrorMessage("Failed to initialize Supabase");
            return false;
          }

          // Save config using Figma's storage via message passing
          parent.postMessage(
            {
              pluginMessage: {
                type: "save-supabase-config",
                url: url,
                key: key,
              },
            },
            "*"
          );
        }

        try {
          // First check if we have an authenticated session
          const { data: authData, error: sessionError } =
            await supabaseClient.auth.getSession();

          console.log(
            "Auth check result:",
            sessionError ? "Error" : "Success",
            authData
          );

          // If there's no valid session, show the auth modal
          if (sessionError || !authData.session || !authData.session.user) {
            console.log("No active session found, authentication required");
            showModal(authModal);
            return false;
          }

          const userId = authData.session.user.id;
          console.log("User authenticated with ID:", userId);

          // Delete existing non-built-in collections first
          const { error: deleteError } = await supabaseClient
            .from("collections")
            .delete()
            .eq("user_id", userId)
            .not("is_built_in", true);

          if (deleteError) {
            console.error("Error deleting existing collections:", deleteError);
            showErrorMessage("Error during sync: " + deleteError.message);
            return false;
          }

          // Prepare collections data with user_id
          const collectionsToSync = pluginData.collections
            .filter((collection) => !collection.isBuiltIn)
            .map((collection) => ({
              id: collection.id,
              name: collection.name,
              presets: collection.presets,
              is_built_in: collection.isBuiltIn || false,
              user_id: userId, // Explicitly set user_id to match authenticated user
              last_synced_at: new Date().toISOString(),
            }));

          console.log("Syncing collections:", collectionsToSync.length);

          // If no collections to sync, just return success
          if (collectionsToSync.length === 0) {
            // Update sync status even though no data was synced
            const now = new Date();
            document.querySelector(
              ".sync-status"
            ).textContent = `Last synced: ${now.toLocaleTimeString()}`;
            pluginData.lastSyncedAt = now.getTime();
            return true;
          }

          // Insert collections with user_id
          const { error: upsertError } = await supabaseClient
            .from("collections")
            .upsert(collectionsToSync, {
              onConflict: "id", // Handle conflicts by ID
              ignoreDuplicates: false, // Update existing records
            });

          if (upsertError) {
            console.error("Upsert error:", upsertError);
            showErrorMessage("Error during sync: " + upsertError.message);
            return false;
          }

          // Update sync status
          const now = new Date();
          document.querySelector(
            ".sync-status"
          ).textContent = `Last synced: ${now.toLocaleTimeString()}`;
          pluginData.lastSyncedAt = now.getTime();

          // Notify Figma
          parent.postMessage(
            {
              pluginMessage: {
                type: "sync-to-supabase",
                success: true,
              },
            },
            "*"
          );

          return true;
        } catch (error) {
          console.error("Sync error:", error);
          showErrorMessage("Failed to sync: " + error.message);
          return false;
        }
      }

      // Add function to import from Supabase
      async function importFromSupabase() {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          return false;
        }

        try {
          // First check if we have an authenticated session
          const { data: authData, error: sessionError } =
            await supabaseClient.auth.getSession();

          console.log(
            "Auth check result:",
            sessionError ? "Error" : "Success",
            authData
          );

          // If there's no valid session, show the auth modal
          if (sessionError || !authData.session || !authData.session.user) {
            console.log("No active session found, authentication required");
            showModal(authModal);
            return false;
          }

          const userId = authData.session.user.id;
          console.log("User authenticated with ID:", userId);

          // Only get collections that belong to this user (enforcing userId requirement)
          const { data, error } = await supabaseClient
            .from("collections")
            .select("*")
            .eq("user_id", userId)
            .order("created_at", { ascending: true });

          if (error) {
            console.error("Import query error:", error);
            showErrorMessage("Error during import: " + error.message);
            return false;
          }

          if (!data || data.length === 0) {
            showErrorMessage("No collections found for your account");
            return false;
          }

          console.log("Found collections to import:", data.length);

          // Merge with existing collections, avoiding duplicates
          const existingIds = new Set(pluginData.collections.map((c) => c.id));
          const newCollections = data.filter((c) => !existingIds.has(c.id));

          // If all collections exist already
          if (newCollections.length === 0) {
            showErrorMessage("All collections already exist in your workspace");
            return true;
          }

          // Add the collections
          pluginData.collections = [
            ...pluginData.collections,
            ...newCollections,
          ];

          // Update UI
          renderCollections();

          // Notify Figma
          parent.postMessage(
            {
              pluginMessage: {
                type: "update",
                data: pluginData,
              },
            },
            "*"
          );

          return true;
        } catch (error) {
          console.error("Import error:", error);
          showErrorMessage("Failed to import: " + error.message);
          return false;
        }
      }

      // Add function to import from Supabase using a share code
      async function importSharedCollection() {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          // Focus the input field again
          setTimeout(() => importIdInput.focus(), 10);
          return false;
        }

        try {
          // Get the share code from the input and save it in a variable
          const shareCode = importIdInput.value.trim();
          if (!shareCode) {
            showErrorMessage("Please enter a valid share code");
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Show loading state
          importCollectionBtn.disabled = true;
          importCollectionBtn.textContent = "Importing...";

          // Debug log the actual input
          console.log("Attempting import with code:", shareCode);

          let query;
          let queryType = "unknown";

          // Check if the input is a full UUID in standard format (8-4-4-4-12 characters)
          const uuidPattern =
            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

          if (uuidPattern.test(shareCode)) {
            // If it's a full UUID, do an exact match
            query = supabaseClient
              .from("shared_collections")
              .select("*")
              .eq("share_id", shareCode);

            queryType = "exact-uuid";
            console.log("Using exact UUID match for:", shareCode);
          } else {
            // Otherwise, try the partial match approach
            query = supabaseClient
              .from("shared_collections")
              .select("*")
              .ilike("share_id", `${shareCode}%`);

            queryType = "partial-match";
            console.log("Using partial match for:", shareCode);
          }

          // Debug log the query before executing
          console.log(`Executing ${queryType} query...`);

          // Execute the query
          const { data: sharedCollections, error: fetchError } = await query;

          console.log("Query results:", {
            queryType,
            count: sharedCollections?.length || 0,
            error: fetchError?.message,
          });

          // Restore button state
          importCollectionBtn.disabled = false;
          importCollectionBtn.textContent = "Import";

          if (fetchError) {
            console.error(
              "Database error fetching shared collection:",
              fetchError
            );
            showErrorMessage("Database error: " + fetchError.message);
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          if (!sharedCollections || sharedCollections.length === 0) {
            console.error("No collection found with ID:", shareCode);
            showErrorMessage(
              "Collection not found with this code. Make sure you entered it correctly."
            );
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Use the first result
          const sharedCollection = sharedCollections[0];
          console.log("Found collection:", sharedCollection?.name);

          if (
            !sharedCollection.presets ||
            !Array.isArray(sharedCollection.presets)
          ) {
            console.error(
              "Invalid collection format - missing presets:",
              sharedCollection
            );
            showErrorMessage("The imported collection has an invalid format.");
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Check if this collection already exists
          const collectionExists = pluginData.collections.some(
            (c) => c.id === sharedCollection.collection_id
          );

          if (collectionExists) {
            console.log("Collection already exists in workspace");
            showErrorMessage("This collection is already in your workspace");
            // Focus the input field again
            setTimeout(() => importIdInput.focus(), 10);
            return false;
          }

          // Ensure all presets have isFavorite set to false
          const unfavoritedPresets = sharedCollection.presets.map((preset) => ({
            ...preset,
            isFavorite: false, // Explicitly set all presets to not be favorites
          }));

          // Create a new copy of the collection with a new ID to avoid conflicts
          const newCollection = {
            id: "collection-" + Date.now(), // New unique ID
            name: sharedCollection.name + " (Shared)",
            presets: unfavoritedPresets, // Use the unfavorited presets
            isBuiltIn: false,
            dateImported: Date.now(), // Add import date for reference
          };

          console.log("Created new collection object:", {
            id: newCollection.id,
            name: newCollection.name,
            presetCount: newCollection.presets.length,
          });

          // Add the collection to the local data
          pluginData.collections.push(newCollection);

          // Update UI
          console.log("Updating UI with new collection");
          renderCollections();

          // Notify Figma to save the imported collection to client storage
          // This ensures the collection persists after plugin restart
          parent.postMessage(
            {
              pluginMessage: {
                type: "save-imported-collection",
                collection: newCollection,
                data: pluginData, // Send full data for backup
              },
            },
            "*"
          );

          // Close modal and show success message
          hideModal(importCollectionModal);
          showSuccessMessage(
            "Collection imported successfully and saved locally"
          );

          // Reset input for next time
          importIdInput.value = "";

          return true;
        } catch (error) {
          console.error("Import error:", error);
          showErrorMessage(
            "Failed to import: " + (error.message || "Unknown error")
          );

          // Restore button state
          importCollectionBtn.disabled = false;
          importCollectionBtn.textContent = "Import";

          // Focus the input field again
          setTimeout(() => importIdInput.focus(), 10);
          return false;
        }
      }

      // ============================================================
      // Rendering Functions
      // ============================================================

      // Setup drag and drop functionality for collections
      function setupCollectionDragAndDrop() {
        let draggingElement = null;
        let previousOrder = [];

        // Store the current order of collections
        function saveCurrentOrder() {
          const collections = document.querySelectorAll(".collection");
          previousOrder = Array.from(collections)
            .filter((el) => el.querySelector(".collection-header"))
            .map((el) => el.querySelector(".collection-header").dataset.id);
          return previousOrder;
        }

        // Save new order to Figma
        function saveNewOrder() {
          const collections = document.querySelectorAll(".collection");
          const newOrder = Array.from(collections)
            .filter((el) => el.querySelector(".collection-header"))
            .map((el) => el.querySelector(".collection-header").dataset.id)
            .filter((id) => id !== "favorites"); // Filter out the favorites virtual collection

          console.log("Previous order:", previousOrder);
          console.log("New order:", newOrder);

          // Always send the reorder message to make sure it's processed
          parent.postMessage(
            {
              pluginMessage: {
                type: "reorder-collections",
                collectionIds: newOrder,
              },
            },
            "*"
          );
        }

        // Setup drag and drop for each collection header
        document.querySelectorAll(".collection-header").forEach((header) => {
          // Skip favorites collection which shouldn't be draggable
          if (header.dataset.id === "favorites") {
            header.setAttribute("draggable", "false");
            return;
          }

          // Dragstart - when user starts dragging
          header.addEventListener("dragstart", (e) => {
            draggingElement = header.closest(".collection");
            draggingElement.classList.add("dragging");

            // Set data for drag operation
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", header.dataset.id);

            // Store current order
            saveCurrentOrder();

            // Add delay for visual feedback
            setTimeout(() => {
              draggingElement.style.opacity = "0.6";
            }, 0);
          });

          // Dragend - when user releases the element
          header.addEventListener("dragend", () => {
            if (draggingElement) {
              draggingElement.classList.remove("dragging");
              draggingElement.style.opacity = "1";
              draggingElement = null;

              // Remove drag-over styling
              document.querySelectorAll(".collection-header").forEach((h) => {
                h.classList.remove("drag-over");
              });

              // Save the new order
              saveNewOrder();
            }
          });

          // Dragover - as dragged element moves over potential drop targets
          header.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";

            const container = header.closest(".collection");
            if (
              container !== draggingElement &&
              header.dataset.id !== "favorites"
            ) {
              header.classList.add("drag-over");
            }
          });

          // Dragleave - when dragged element leaves a potential drop target
          header.addEventListener("dragleave", () => {
            header.classList.remove("drag-over");
          });

          // Drop - when element is dropped
          header.addEventListener("drop", (e) => {
            e.preventDefault();
            header.classList.remove("drag-over");

            if (!draggingElement) return;

            const targetContainer = header.closest(".collection");
            if (
              targetContainer !== draggingElement &&
              header.dataset.id !== "favorites"
            ) {
              const containers = Array.from(
                document.querySelectorAll(".collection")
              );
              const dragIndex = containers.indexOf(draggingElement);
              const targetIndex = containers.indexOf(targetContainer);

              // Determine if we need to insert before or after
              if (dragIndex < targetIndex) {
                document
                  .querySelector(".collections-container")
                  .insertBefore(draggingElement, targetContainer.nextSibling);
              } else {
                document
                  .querySelector(".collections-container")
                  .insertBefore(draggingElement, targetContainer);
              }
            }
          });
        });
      }

      // Render all collections
      function renderCollections() {
        collectionsContainer.innerHTML = "";

        // Check if pluginData exists before proceeding
        if (!pluginData || !pluginData.collections) {
          collectionsContainer.innerHTML = `<div class="empty-state">Loading collections...</div>`;
          return;
        }

        // Create a virtual Favorites collection at the top
        const favorites = [];

        // Get all favorite presets across collections
        pluginData.collections.forEach((collection) => {
          collection.presets.forEach((preset) => {
            if (preset.isFavorite) {
              favorites.push({
                ...preset,
                collectionId: collection.id,
                collectionName: collection.name,
              });
            }
          });
        });

        // Add Favorites as a virtual collection
        if (favorites.length > 0) {
          const favoritesEl = document.createElement("div");
          favoritesEl.classList.add(`collection`);
          favoritesEl.classList.add(`collection-favorites`);

          // Create favorites collection header
          favoritesEl.innerHTML = `
          <div class="collection-header" data-id="favorites" style="padding: 6px 12px;">
            <div class="arrow" style="margin-left: 0px;"></div>
            <div class="collection-name" style="display: flex; align-items: center; margin-left: 0px;">
              Favorites
            </div>
          </div>
          <div class="collection-content" data-collection-id="favorites">
            <div class="presets-list">
              ${favorites
                .map((preset) => {
                  // Calculate frame preview dimensions for visualization using SVG
                  const maxPreviewSize = 24; // Reduced from 36px to 24px to match regular collections
                  let previewWidth, previewHeight;

                  // Calculate proper dimensions maintaining aspect ratio
                  if (preset.width > preset.height) {
                    previewWidth = maxPreviewSize;
                    previewHeight =
                      (preset.height / preset.width) * maxPreviewSize;
                  } else {
                    previewHeight = maxPreviewSize;
                    previewWidth =
                      (preset.width / preset.height) * maxPreviewSize;
                  }

                  // Create SVG visualization of the frame
                  return `
                <div class="preset-card" data-id="${
                  preset.id
                }" data-collection="${preset.collectionId}">
                  <div class="preset-preview">
                    <svg width="${maxPreviewSize}" height="${maxPreviewSize}" viewBox="0 0 ${maxPreviewSize} ${maxPreviewSize}" xmlns="http://www.w3.org/2000/svg">
                      <rect 
                        x="${(maxPreviewSize - previewWidth) / 2}" 
                        y="${(maxPreviewSize - previewHeight) / 2}" 
                        width="${previewWidth}" 
                        height="${previewHeight}" 
                        class="frame-rect-fill" />
                    </svg>
                  </div>
                  <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-dimensions-row">
                      <button class="favorite-btn active" data-id="${
                        preset.id
                      }" data-collection="${preset.collectionId}">
                        <svg width="16" height="16" viewBox="0 0 12 12" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                          <path d="M5.95 1.37724C5.9776 1.32251 6.0224 1.32251 6.05 1.37724L7.5595 4.42717C7.57224 4.45394 7.59776 4.47125 7.62709 4.47456L10.9639 4.92686C11.0243 4.93462 11.0463 5.00876 11.0012 5.0529L8.55513 7.42616C8.53316 7.44749 8.52325 7.47852 8.52855 7.50779L9.12376 10.8254C9.13402 10.8855 9.07045 10.9328 9.01734 10.9054L6.07474 9.36736C6.0479 9.35256 6.0141 9.35438 5.98869 9.37122L3.10501 11.0304C3.05287 11.0608 2.98701 11.0163 2.99478 10.9559L3.47124 7.61922C3.47551 7.58973 3.46456 7.55909 3.44183 7.53851L0.9422 5.24822C0.895218 5.20623 0.914854 5.13149 0.97477 5.12181L4.29308 4.54424C4.32225 4.53993 4.34671 4.52183 4.35816 4.49471L5.95 1.37724Z" fill="currentColor" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                      </button>
                      <div class="preset-dimensions">${formatDimensions(
                        preset.width,
                        preset.height
                      )}</div>
                    </div>
                  </div>
                </div>
              `;
                })
                .join("")}
            </div>
          </div>
          `;

          collectionsContainer.appendChild(favoritesEl);
        }

        // Then render all regular collections
        pluginData.collections.forEach((collection) => {
          const isActive = collection.id === pluginData.activeCollectionId;
          const collectionEl = document.createElement("div");
          collectionEl.classList.add(`collection`);
          collectionEl.classList.add(`collection-${collection.id}`);

          // Add active class if this collection is active
          if (isActive) {
            collectionEl.classList.add("active-collection");
          }

          // Create collection header in a style similar to the screenshot
          collectionEl.innerHTML = `
          <div class="collection-header" data-id="${
            collection.id
          }" draggable="true">
            <div class="arrow"></div>
            <div class="collection-name">
              ${collection.name}
            </div>
            <div class="collection-header-right">
              <div class="collection-actions">
                <button class="share-collection-btn" data-id="${
                  collection.id
                }" data-tooltip="Share collection">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.68439 10.6578L15.3124 7.34378M15.3156 16.6578L8.69376 13.3469M21 6C21 7.65685 19.6569 9 18 9C16.3431 9 15 7.65685 15 6C15 4.34315 16.3431 3 18 3C19.6569 3 21 4.34315 21 6ZM21 18C21 19.6569 19.6569 21 18 21C16.3431 21 15 19.6569 15 18C15 16.3431 16.3431 15 18 15C19.6569 15 21 16.3431 21 18ZM9 12C9 13.6569 7.65685 15 6 15C4.34315 15 3 13.6569 3 12C3 10.3431 4.34315 9 6 9C7.65685 9 9 10.3431 9 12Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="delete-collection-btn" data-id="${
                  collection.id
                }" data-tooltip="Delete collection">
                  <svg width="14" height="14" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M1 3H11M4 3V2.5C4 1.67157 4.67157 1 5.5 1H6.5C7.32843 1 8 1.67157 8 2.5V3M9 3V10C9 10.5523 8.55228 11 8 11H4C3.44772 11 3 10.5523 3 10V3" stroke="currentColor" stroke-width="1.5"/>
                  </svg>
                </button>
                <div class="drag-handle">
                  <svg width="10" height="10" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M7 5H5M7 10H5M7 15H5M15 5H13M15 10H13M15 15H13" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>
          <div class="collection-content" data-collection-id="${collection.id}">
            <div class="presets-list">
              ${
                collection.presets.length > 0
                  ? collection.presets
                      .map((preset) => {
                        // Calculate frame preview dimensions for visualization using SVG
                        const maxPreviewSize = 24; // Reduced from 36px to 24px
                        let previewWidth, previewHeight;

                        // Calculate proper dimensions maintaining aspect ratio
                        if (preset.width > preset.height) {
                          previewWidth = maxPreviewSize;
                          previewHeight =
                            (preset.height / preset.width) * maxPreviewSize;
                        } else {
                          previewHeight = maxPreviewSize;
                          previewWidth =
                            (preset.width / preset.height) * maxPreviewSize;
                        }

                        // Create SVG visualization of the frame
                        return `
                <div class="preset-card" data-id="${
                  preset.id
                }" data-collection="${collection.id}">
                  <div class="preset-preview">
                    <svg width="${maxPreviewSize}" height="${maxPreviewSize}" viewBox="0 0 ${maxPreviewSize} ${maxPreviewSize}" xmlns="http://www.w3.org/2000/svg">
                      <rect 
                        x="${(maxPreviewSize - previewWidth) / 2}" 
                        y="${(maxPreviewSize - previewHeight) / 2}" 
                        width="${previewWidth}" 
                        height="${previewHeight}" 
                        class="frame-rect-fill" />
                    </svg>
                  </div>
                  <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-dimensions-row">
                      <button class="favorite-btn ${
                        preset.isFavorite ? "active" : ""
                      }" data-id="${preset.id}" data-collection="${
                          collection.id
                        }" data-tooltip="${
                          preset.isFavorite
                            ? "Remove from favorites"
                            : "Add to favorites"
                        }">
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="${
                          preset.isFavorite ? "currentColor" : "none"
                        }" xmlns="http://www.w3.org/2000/svg">
                          <path d="M5.95 1.37724C5.9776 1.32251 6.0224 1.32251 6.05 1.37724L7.5595 4.42717C7.57224 4.45394 7.59776 4.47125 7.62709 4.47456L10.9639 4.92686C11.0243 4.93462 11.0463 5.00876 11.0012 5.0529L8.55513 7.42616C8.53316 7.44749 8.52325 7.47852 8.52855 7.50779L9.12376 10.8254C9.13402 10.8855 9.07045 10.9328 9.01734 10.9054L6.07474 9.36736C6.0479 9.35256 6.0141 9.35438 5.98869 9.37122L3.10501 11.0304C3.05287 11.0608 2.98701 11.0163 2.99478 10.9559L3.47124 7.61922C3.47551 7.58973 3.46456 7.55909 3.44183 7.53851L0.9422 5.24822C0.895218 5.20623 0.914854 5.13149 0.97477 5.12181L4.29308 4.54424C4.32225 4.53993 4.34671 4.52183 4.35816 4.49471L5.95 1.37724Z" fill="${
                            preset.isFavorite ? "currentColor" : "transparent"
                          }" stroke="currentColor" stroke-width="1.5"/>
                        </svg>
                      </button>
                      <div class="preset-dimensions">${formatDimensions(
                        preset.width,
                        preset.height
                      )}</div>
                    </div>
                  </div>
                  ${
                    !collection.isBuiltIn && preset.dateCreated > 1000000000000
                      ? `
                  <div class="preset-actions">
                    <button class="delete-preset-btn" data-id="${preset.id}" data-collection="${collection.id}" data-tooltip="Delete preset">
                      <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M2 3H10M4 3V2.5C4 1.67157 4.67157 1 5.5 1H6.5C7.32843 1 8 1.67157 8 2.5V3M9 3V10C9 10.5523 8.55228 11 8 11H4C3.44772 11 3 10.5523 3 10V3" stroke="currentColor" stroke-width="1.5"/>
                      </svg>
                    </button>
                  </div>
                  `
                      : ""
                  }                
                </div>
              `;
                      })
                      .join("")
                  : `<div class="empty-state" style="border: none; border-top: none; border-bottom: none;">No presets in this collection. Create one using the "Save Current Frame" button.</div>`
              }
            </div>
          </div>
        `;

          collectionsContainer.appendChild(collectionEl);
        });

        // Set up event listeners for the newly created elements
        setupCollectionEventListeners();

        // Setup drag and drop for collection reordering
        setupCollectionDragAndDrop();

        // Ensure the active collection remains expanded
        ensureActiveCollectionExpanded();
      }

      // Favorites are now handled directly inside the renderCollections function

      // Ensure the active-collection class is updated when the active collection changes
      function updateActiveCollectionClass() {
        document.querySelectorAll(".collection").forEach((collectionEl) => {
          const collectionId = collectionEl.getAttribute("data-id");
          if (collectionId === pluginData.activeCollectionId) {
            collectionEl.classList.add("active-collection");
          } else {
            collectionEl.classList.remove("active-collection");
          }
        });
      }

      // Set up event listeners for collection elements
      function setupCollectionEventListeners() {
        document.querySelectorAll(".collection-header").forEach((header) => {
          header.addEventListener("click", (e) => {
            e.stopPropagation();

            const collectionId = header.getAttribute("data-id");
            const arrow = header.querySelector(".arrow");
            const contentDiv = document.querySelector(
              `.collection-content[data-collection-id="${collectionId}"]`
            );
            const isExpanded = arrow && arrow.classList.contains("expanded");

            // Handle "Favorites" collection separately
            if (collectionId === "favorites") {
              if (isExpanded) {
                arrow.classList.remove("expanded");
                contentDiv.classList.remove("expanded");
              } else {
                arrow.classList.add("expanded");
                contentDiv.classList.add("expanded");
              }
              pluginData.activeCollectionId = collectionId; // Ensure "Favorites" can also be active
              updateActiveCollectionClass();
              return; // Exit early to avoid affecting other collections
            }

            // Collapse all other collections (except "Favorites")
            document
              .querySelectorAll(".collection-header .arrow")
              .forEach((otherArrow) => {
                const parentHeader = otherArrow.closest(".collection-header");
                const parentCollectionId =
                  parentHeader?.getAttribute("data-id");
                if (
                  parentCollectionId !== "favorites" &&
                  parentCollectionId !== collectionId
                ) {
                  otherArrow.classList.remove("expanded");
                }
              });
            document
              .querySelectorAll(".collection-content.expanded")
              .forEach((otherContent) => {
                const parentContentId =
                  otherContent.getAttribute("data-collection-id");
                if (
                  parentContentId !== "favorites" &&
                  parentContentId !== collectionId
                ) {
                  otherContent.classList.remove("expanded");
                }
              });

            // Toggle the clicked collection's expansion state
            if (isExpanded) {
              arrow.classList.remove("expanded");
              contentDiv.classList.remove("expanded");
            } else {
              arrow.classList.add("expanded");
              contentDiv.classList.add("expanded");
            }

            // Set the clicked collection as active
            pluginData.activeCollectionId = collectionId;
            updateActiveCollectionClass();
          });
        });

        // Delete collection
        document.querySelectorAll(".delete-collection-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const collectionId = btn.getAttribute("data-id");

            if (confirm("Are you sure you want to delete this collection?")) {
              // Notify Figma
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "delete-collection",
                    collectionId: collectionId,
                  },
                },
                "*"
              );
            }
          });
        });

        // Share collection
        document.querySelectorAll(".share-collection-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const collectionId = btn.getAttribute("data-id");
            shareCollection(collectionId);
          });
        });

        // Preset card click (use preset)
        document.querySelectorAll(".preset-card").forEach((card) => {
          card.addEventListener("click", (e) => {
            // Don't use preset if clicking the favorite button or delete button
            if (
              e.target.closest(".favorite-btn") ||
              e.target.closest(".delete-preset-btn")
            )
              return;

            const presetId = card.dataset.id;
            const collectionId = card.dataset.collection;

            const collection = pluginData.collections.find(
              (c) => c.id === collectionId
            );
            if (!collection) return;

            const preset = collection.presets.find((p) => p.id === presetId);
            if (!preset) return;

            // Send the 'apply-preset' message type to handle both applying to selection
            // and creating new frames when nothing is selected
            parent.postMessage(
              {
                pluginMessage: {
                  type: "apply-preset",
                  presetId,
                  collectionId,
                },
              },
              "*"
            );
          });
        });

        // Delete preset button click
        document.querySelectorAll(".delete-preset-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const presetId = btn.getAttribute("data-id");
            const collectionId = btn.getAttribute("data-collection");

            // Get the current expanded state to preserve it during animation
            saveExpandedState();

            // Add a removing animation
            const card = btn.closest(".preset-card");
            if (card) {
              card.classList.add("preset-card-removing");
            }

            // Notify Figma after a short delay for animation
            setTimeout(() => {
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "delete-preset",
                    presetId: presetId,
                    collectionId: collectionId,
                  },
                },
                "*"
              );
            }, 100);
          });
        });

        // Favorite button click
        document.querySelectorAll(".favorite-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const presetId = e.currentTarget.dataset.id;
            const collectionId = e.currentTarget.dataset.collection;
            const card = e.currentTarget.closest(".preset-card");

            // Get the current expanded state to preserve it during animation
            saveExpandedState();

            // Toggle the favorite state visually immediately for instant feedback
            const isFavorite = e.currentTarget.classList.contains("active");
            if (isFavorite) {
              e.currentTarget.classList.remove("active");
              const svg = e.currentTarget.querySelector("svg");
              if (svg) svg.setAttribute("fill", "transparent");

              // If removing from favorites section, animate removal
              if (
                card &&
                document.querySelector(".favorites-section") &&
                card.closest(".favorites-section")
              ) {
                card.classList.add("preset-card-removing");
                // Wait for animation before notifying Figma
                setTimeout(() => {
                  // Notify Figma only after animation starts
                  parent.postMessage(
                    {
                      pluginMessage: {
                        type: "toggle-favorite",
                        presetId,
                        collectionId,
                      },
                    },
                    "*"
                  );
                }, 100); // Short delay for animation to start
                return;
              }
            } else {
              e.currentTarget.classList.add("active");
              const svg = e.currentTarget.querySelector("svg");
              if (svg) svg.setAttribute("fill", "currentColor");
            }

            // Notify Figma for normal cases
            parent.postMessage(
              {
                pluginMessage: {
                  type: "toggle-favorite",
                  presetId,
                  collectionId,
                },
              },
              "*"
            );
          });
        });
      }

      // ============================================================
      // Event Listeners
      // ============================================================

      // Theme toggle
      themeToggle.addEventListener("click", toggleTheme);

      // Create new collection
      newCollectionBtn.addEventListener("click", () => {
        collectionNameInput.value = "";
        showModal(newCollectionModal);
      });

      // Save new collection
      saveCollectionBtn.addEventListener("click", () => {
        const name = collectionNameInput.value.trim();
        if (!name) return;

        // Notify Figma
        parent.postMessage(
          {
            pluginMessage: {
              type: "create-collection",
              name,
            },
          },
          "*"
        );

        hideModal(newCollectionModal);

        // If we have a flag to create preset after collection, trigger the preset creation
        if (window.createPresetAfterCollection) {
          // Reset the flag
          window.createPresetAfterCollection = false;

          // Set a timeout to allow the collection to be created first
          setTimeout(() => {
            // We'll request the current selection data from Figma
            // The targetCollectionId will be set in the onmessage handler when we get the update
            parent.postMessage(
              {
                pluginMessage: {
                  type: "create-preset",
                },
              },
              "*"
            );
          }, 300);
        }
      });

      // Cancel new collection
      cancelCollectionBtn.addEventListener("click", () => {
        hideModal(newCollectionModal);
      });

      // Create preset
      createPresetBtn.addEventListener("click", () => {
        // First check if any custom collections exist
        const customCollections = pluginData.collections.filter(
          (c) => !c.isBuiltIn
        );

        // If no custom collections exist, prompt to create one
        if (customCollections.length === 0) {
          if (
            confirm(
              "You need to create a collection first to save frames. Would you like to create one now?"
            )
          ) {
            collectionNameInput.value = "";
            showModal(newCollectionModal);

            // Set a flag to indicate we should create a preset after collection is created
            window.createPresetAfterCollection = true;
          }
          return;
        }

        // If no active collection or active collection is built-in, use the first custom collection
        const activeCollection = pluginData.collections.find(
          (c) => c.id === pluginData.activeCollectionId
        );
        let targetCollectionId = pluginData.activeCollectionId;

        if (!activeCollection || activeCollection.isBuiltIn) {
          targetCollectionId = customCollections[0].id;
          console.log("Using first custom collection:", targetCollectionId);
        }

        // Request current selection from Figma
        parent.postMessage(
          {
            pluginMessage: {
              type: "create-preset",
              targetCollectionId: targetCollectionId,
            },
          },
          "*"
        );
      });

      // Save preset
      savePresetBtn.addEventListener("click", () => {
        // Get all frame inputs
        const frameInputGroups =
          document.querySelectorAll(".frame-input-group");

        if (frameInputGroups.length === 0) {
          showErrorMessage("No frames to save");
          return;
        }

        // Store original frame data that came from Figma
        const originalFrameData = window.currentFrameData || [];
        console.log("Original frame data count:", originalFrameData.length);

        // Track the total number of presets to save
        const presetsToSave = [];

        // Loop through each frame input group
        frameInputGroups.forEach((group, index) => {
          const nameInput = group.querySelector(".frame-name-input");
          const widthInput = group.querySelector(".frame-width-input");
          const heightInput = group.querySelector(".frame-height-input");

          if (!nameInput || !widthInput || !heightInput) {
            console.error("Missing input fields");
            return;
          }

          // Get input values
          const name = nameInput.value.trim();
          const width = parseFloat(widthInput.value);
          const height = parseFloat(heightInput.value);

          // Validate
          if (name && !isNaN(width) && !isNaN(height)) {
            // Find the corresponding original frame data for this specific frame
            // Use the index to ensure we match with the correct frame data
            const originalFrame = originalFrameData[index];

            if (!originalFrame) {
              console.error(`Original frame data missing for index ${index}`);
              return;
            }

            console.log(
              `Creating preset for frame ${index}: ${name} (${width}×${height})`
            );

            // Create a completely separate, independent preset object to avoid property sharing
            const preset = {
              id: generateId() + "-" + index, // Ensure unique IDs with index
              name: name,
              width: width,
              height: height,
              isFavorite: false,
              dateCreated: Date.now(),

              // Deep clone all frame properties to break object references
              // This ensures each frame maintains its own unique properties
              fills: JSON.parse(JSON.stringify(originalFrame.fills || [])),
              strokes: JSON.parse(JSON.stringify(originalFrame.strokes || [])),
              strokeWeight: originalFrame.strokeWeight,
              cornerRadius:
                typeof originalFrame.cornerRadius === "object"
                  ? JSON.parse(JSON.stringify(originalFrame.cornerRadius))
                  : originalFrame.cornerRadius,
              effects: JSON.parse(JSON.stringify(originalFrame.effects || [])),
              layoutMode: originalFrame.layoutMode,
              primaryAxisSizingMode: originalFrame.primaryAxisSizingMode,
              counterAxisSizingMode: originalFrame.counterAxisSizingMode,
              primaryAxisAlignItems: originalFrame.primaryAxisAlignItems,
              counterAxisAlignItems: originalFrame.counterAxisAlignItems,
              paddingLeft: originalFrame.paddingLeft,
              paddingRight: originalFrame.paddingRight,
              paddingTop: originalFrame.paddingTop,
              paddingBottom: originalFrame.paddingBottom,
              itemSpacing: originalFrame.itemSpacing,
              clipsContent: originalFrame.clipsContent,
            };

            // Add preset to the list to save
            presetsToSave.push(preset);
          }
        });

        // If we have presets to save, send them all at once to Figma
        if (presetsToSave.length > 0) {
          console.log(`Sending ${presetsToSave.length} presets to Figma`);

          // Notify Figma to save all presets at once
          parent.postMessage(
            {
              pluginMessage: {
                type: "save-multiple-presets",
                presets: presetsToSave,
                collectionId: pluginData.activeCollectionId,
              },
            },
            "*"
          );

          // Show success message
          showSuccessMessage(
            `Saved ${presetsToSave.length} preset${
              presetsToSave.length > 1 ? "s" : ""
            }`
          );
        }

        hideModal(createPresetModal);
      });

      // Cancel preset
      cancelPresetBtn.addEventListener("click", () => {
        hideModal(createPresetModal);
      });

      // Import button
      importBtn.addEventListener("click", () => {
        importIdInput.value = "";
        showModal(importCollectionModal);
      });

      // Import collection
      importCollectionBtn.addEventListener("click", async () => {
        const success = await importSharedCollection();
        if (success) {
          hideModal(importCollectionModal);
          showSuccessMessage("Collection imported successfully");
        } else {
          showErrorMessage("Failed to import collection");
        }
      });

      // Cancel import
      cancelImportBtn.addEventListener("click", () => {
        hideModal(importCollectionModal);
      });

      // Copy share link
      copyShareLinkBtn.addEventListener("click", () => {
        try {
          // Method 1: Modern Clipboard API
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard
              .writeText(shareLink.textContent)
              .then(() => {
                copyShareLinkBtn.textContent = "Copied!";
                setTimeout(() => {
                  copyShareLinkBtn.textContent = "Copy to Clipboard";
                }, 2000);
              })
              .catch((err) => fallbackCopyToClipboard(shareLink.textContent));
          } else {
            // Method 2: Selection and execCommand
            fallbackCopyToClipboard(shareLink.textContent);
          }
        } catch (err) {
          console.error("Copy failed:", err);
          showErrorMessage(
            "Failed to copy. Please select and copy the text manually."
          );
        }
      });

      // Fallback copy method using selection
      function fallbackCopyToClipboard(text) {
        // Create temporary textarea
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.width = "2em";
        textArea.style.height = "2em";
        textArea.style.padding = "0";
        textArea.style.border = "none";
        textArea.style.outline = "none";
        textArea.style.boxShadow = "none";
        textArea.style.background = "transparent";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          const successful = document.execCommand("copy");
          if (successful) {
            copyShareLinkBtn.textContent = "Copied!";
            setTimeout(() => {
              copyShareLinkBtn.textContent = "Copy to Clipboard";
            }, 2000);
          } else {
            console.error("Copy command was unsuccessful");
          }
        } catch (err) {
          console.error("Error during copy:", err);
        }

        document.body.removeChild(textArea);
      }

      // Close share modal
      closeShareModalBtn.addEventListener("click", () => {
        hideModal(shareCollectionModal);
      });

      // Sync button
      syncBtn.addEventListener("click", async () => {
        const success = await syncToSupabase();
        if (success) {
          showSuccessMessage("Sync completed successfully");
        }
      });

      // Test connection button
      checkConnectionBtn.addEventListener("click", async () => {
        if (!supabaseClient) {
          const url = supabaseUrlInput.value.trim();
          const key = supabaseKeyInput.value.trim();

          if (!url || !key) {
            showModal(supabaseConfigModal);
            return;
          }

          const success = await initSupabase(url, key);
          if (!success) {
            showErrorMessage("Failed to initialize Supabase");
            return;
          }
        }

        try {
          const { data, error } = await supabaseClient
            .from("collections")
            .select("*")
            .limit(1);
          if (error) throw error;
          showSuccessMessage("Connection successful!");
        } catch (error) {
          console.error("Connection test error:", error);
          showErrorMessage(
            "Connection failed. Please check your Supabase configuration."
          );
        }
      });

      // Save Supabase config
      saveSupabaseBtn.addEventListener("click", () => {
        const url = supabaseUrlInput.value.trim();
        const key = supabaseKeyInput.value.trim();

        if (!url || !key) {
          showErrorMessage("Please enter both URL and key");
          return;
        }

        supabaseConfig = { url, key };
        hideModal(supabaseConfigModal);

        // After config, try syncing again
        syncToSupabase();
      });

      // Cancel Supabase config
      cancelSupabaseBtn.addEventListener("click", () => {
        hideModal(supabaseConfigModal);
      });

      // Google Sign-in button
      googleSigninBtn.addEventListener("click", async () => {
        try {
          if (!supabaseClient) {
            showErrorMessage("Please configure Supabase first");
            return;
          }

          // Instead of using the regular OAuth flow, use the email-based passwordless sign-in
          const { error } = await supabaseClient.auth.signInWithOAuth({
            provider: "google",
            options: {
              skipBrowserRedirect: false, // Let the main window handle it
              redirectTo: window.location.origin + window.location.pathname,
              queryParams: {
                prompt: "select_account", // Always show account selection
              },
            },
          });

          if (error) {
            console.error("Google auth error:", error);
            showErrorMessage(
              "Failed to start Google authentication: " + error.message
            );
            return;
          }

          // The window will be redirected to Google, and then back with the token in the URL
          // No need for polling as the page will reload with auth data
        } catch (error) {
          console.error("Google sign-in error:", error);
          showErrorMessage("An error occurred during Google sign-in.");
        }
      });

      // Add a function to check URL for auth response on page load
      async function checkForAuthRedirect() {
        try {
          // Get the hash fragment from the URL
          const hash = window.location.hash;
          if (hash && hash.includes("access_token")) {
            // Parse the hash parameters
            const params = new URLSearchParams(hash.substring(1));
            const accessToken = params.get("access_token");

            if (accessToken) {
              // Auth was successful, notify the user
              hideModal(authModal);
              showSuccessMessage("Authentication successful!");

              // Try to sync after successful authentication
              setTimeout(() => {
                syncToSupabase().then((success) => {
                  if (success) {
                    showSuccessMessage("Data has been synced successfully.");
                  }
                });
              }, 1000);

              // Clear the hash from the URL to avoid issues on refresh
              if (history && history.replaceState) {
                history.replaceState(null, null, " ");
              } else {
                window.location.hash = "";
              }
            }
          }
        } catch (error) {
          console.error("Error checking auth redirect:", error);
        }
      }

      // Check for auth redirect when page loads
      window.addEventListener("load", checkForAuthRedirect);

      // Cancel auth
      cancelAuthBtn.addEventListener("click", () => {
        hideModal(authModal);
      });

      // Load saved Supabase config on startup
      window.addEventListener("load", () => {
        // Request Supabase config from plugin instead of using localStorage
        parent.postMessage(
          {
            pluginMessage: {
              type: "get-supabase-config",
            },
          },
          "*"
        );
      });

      // ============================================================
      // Message handling from Figma
      // ============================================================
      window.onmessage = (event) => {
        const msg = event.data.pluginMessage;

        if (!msg) return;

        switch (msg.type) {
          case "init":
            // Initialize with data from Figma
            if (msg.data && msg.data.collections) {
              console.log("Received plugin data:", msg.data);
              pluginData = msg.data;
              renderCollections();
            } else {
              console.error("Received invalid plugin data:", msg.data);
              // Set a default empty state if no valid data is received
              collectionsContainer.innerHTML = `<div class="empty-state">Could not load collections. Please restart the plugin.</div>`;
            }
            break;

          case "update":
            // Update data from Figma
            pluginData = msg.data;
            renderCollections();
            break;

          case "collection-name-exists":
            // Handle duplicate collection name error
            showErrorMessage(
              `Collection name "${msg.name}" already exists. Please use another name.`
            );

            // Re-open the modal and focus the input field
            showModal(newCollectionModal);
            setTimeout(() => {
              // Select the text in the input for easy replacement
              collectionNameInput.select();
              collectionNameInput.focus();
            }, 100);
            break;

          case "active-collection-changed":
            // Only update the active collection state without rerendering
            if (pluginData) {
              pluginData.activeCollectionId = msg.collectionId;

              // Just update the visual active state without full re-render
              document.querySelectorAll(".collection").forEach((coll) => {
                if (coll.classList.contains(`collection-${msg.collectionId}`)) {
                  coll.classList.add("active-collection");
                } else {
                  coll.classList.remove("active-collection");
                }
              });
            }
            break;

          case "supabase-config":
            // Received Supabase configuration from plugin
            if (msg.config && msg.config.url && msg.config.key) {
              supabaseUrlInput.value = msg.config.url;
              supabaseKeyInput.value = msg.config.key;
              initSupabase(msg.config.url, msg.config.key);
            }
            break;

          case "selection-data":
            // Received frame data for preset creation
            presetFramesContainer.innerHTML = "";

            // Store the original frame data for later use when saving the preset
            window.currentFrameData = msg.frames || [];

            if (msg.frames && msg.frames.length > 0) {
              msg.frames.forEach((frame) => {
                const frameGroup = document.createElement("div");
                frameGroup.classList.add("frame-input-group");

                // Calculate aspect ratio for the preview
                const maxPreviewSize = 120;
                let previewWidth, previewHeight;

                if (frame.width > frame.height) {
                  previewWidth = maxPreviewSize;
                  previewHeight = (frame.height / frame.width) * maxPreviewSize;
                } else {
                  previewHeight = maxPreviewSize;
                  previewWidth = (frame.width / frame.height) * maxPreviewSize;
                }

                frameGroup.innerHTML = `
                <div class="frame-preview">
                  <div class="frame-preview-visual" style="width: ${previewWidth}px; height: ${previewHeight}px;"></div>
                </div>
                <label>Name</label>
                <input type="text" class="frame-name-input" value="${
                  frame.name
                }" placeholder="Preset name">
                <div class="frame-dimensions-row">
                  <div class="dimension-group">
                    <label>Width</label>
                    <input type="number" class="frame-width-input" value="${Math.round(
                      frame.width
                    )}" placeholder="Width">
                    <span class="unit-label">px</span>
                  </div>
                  <div class="dimension-group">
                    <label>Height</label>
                    <input type="number" class="frame-height-input" value="${Math.round(
                      frame.height
                    )}" placeholder="Height">
                    <span class="unit-label">px</span>
                  </div>
                </div>
                <div class="input-hint">Original frame: ${formatDimensions(
                  frame.width,
                  frame.height
                )}</div>
              `;

                presetFramesContainer.appendChild(frameGroup);
              });

              showModal(createPresetModal);
            } else {
              showErrorMessage("No frames in selection");
            }
            break;
        }
      };

      // Function to set frame sizes based on aspect ratios - using the improved scaling approach
      function setFrameSizes() {
        // Get all preset cards
        const presetCards = document.querySelectorAll(".preset-card");

        presetCards.forEach((presetCard) => {
          // Find frame visual in this card
          const frameVisual = presetCard.querySelector(".frame-visual");
          if (!frameVisual) return;

          // Get preset ID and collection ID
          const presetId = presetCard.getAttribute("data-id");
          const collectionId = presetCard.getAttribute("data-collection");

          // Find preset data
          let width = 100;
          let height = 100;

          // Find this preset in the plugin data
          if (pluginData && pluginData.collections) {
            const collection = pluginData.collections.find(
              (c) => c.id === collectionId
            );
            if (collection) {
              const preset = collection.presets.find((p) => p.id === presetId);
              if (preset) {
                width = preset.width;
                height = preset.height;
              }
            }
          }

          // Use the same approach as in the Save Frame modal
          const maxPreviewSize = 30; // Slightly larger than before but still appropriate for the list view
          let previewWidth, previewHeight;

          if (width > height) {
            // Landscape
            previewWidth = maxPreviewSize;
            previewHeight = (height / width) * maxPreviewSize;
          } else {
            // Portrait or square
            previewHeight = maxPreviewSize;
            previewWidth = (width / height) * maxPreviewSize;
          }

          // Set the visual style to match the frame dimensions proportionally
          frameVisual.style.width = `${previewWidth}px`;
          frameVisual.style.height = `${previewHeight}px`;

          // Add a subtle border-radius to match the Figma styling
          frameVisual.style.borderRadius = "2px";
        });
      }

      // Track expanded collections to preserve state during re-renders
      let expandedCollections = [];

      // Function to store current expanded state
      function saveExpandedState() {
        expandedCollections = [];
        document
          .querySelectorAll(".collection-content.expanded")
          .forEach((content) => {
            const collectionId = content.getAttribute("data-collection-id");
            if (collectionId) expandedCollections.push(collectionId);
          });
      }

      // Function to restore expanded state
      function restoreExpandedState() {
        expandedCollections.forEach((collectionId) => {
          const contentDiv = document.querySelector(
            `.collection-content[data-collection-id="${collectionId}"]`
          );
          const header = document.querySelector(
            `.collection-header[data-id="${collectionId}"]`
          );
          if (contentDiv) contentDiv.classList.add("expanded");
          if (header) {
            const arrow = header.querySelector(".arrow");
            if (arrow) arrow.classList.add("expanded");
          }
        });
      }

      // Function for smooth UI updates without blinking
      function smoothUpdate(callback) {
        // Execute the update immediately without fade transition
        callback();
      }

      // Apply frame sizing after collections are rendered
      const originalRenderCollections = renderCollections;
      renderCollections = function () {
        // Save expanded state before re-rendering
        saveExpandedState();

        // Call original render function with smooth transition
        smoothUpdate(() => {
          originalRenderCollections.apply(this, arguments);
          // Restore expanded state immediately after rendering
          restoreExpandedState();
          // Apply frame sizing after restoring state
          setFrameSizes();
        });
      };

      // Also apply frame sizing when the UI receives updates
      window.addEventListener("message", function (event) {
        if (
          event.data.pluginMessage &&
          event.data.pluginMessage.type === "update"
        ) {
          // Apply frame sizing after a short delay to ensure DOM is updated
          setTimeout(setFrameSizes, 50);
        }
      });

      // Function to generate a short share ID (for display purposes)
      function generateShareId() {
        // Generate a 6-digit code with letters and numbers
        const characters = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Excluding similar looking characters
        let result = "";
        for (let i = 0; i < 6; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * characters.length)
          );
        }
        return result;
      }

      // Function to share a collection
      async function shareCollection(collectionId) {
        if (!supabaseClient) {
          showErrorMessage("Please configure Supabase first");
          return;
        }

        try {
          // Find the collection
          const collection = pluginData.collections.find(
            (c) => c.id === collectionId
          );
          if (!collection) {
            showErrorMessage("Collection not found");
            return;
          }

          // Create a new entry in the shared_collections table
          const { data: sharedCollection, error } = await supabaseClient
            .from("shared_collections")
            .insert({
              collection_id: collectionId,
              name: collection.name,
              presets: collection.presets,
            })
            .select("share_id")
            .single();

          if (error) {
            console.error("Error sharing collection:", error);
            showErrorMessage("Error sharing collection: " + error.message);
            return;
          }

          // Get the share_id from the response
          const shareId = sharedCollection.share_id;

          // Show the full share ID (not truncated) to ensure exact matching when importing
          shareLink.textContent = shareId;
          showModal(shareCollectionModal);
        } catch (error) {
          console.error("Share error:", error);
          showErrorMessage("Failed to share collection: " + error.message);
        }
      }

      // Add non-blocking notification functions
      function showErrorMessage(message) {
        createAndShowNotification(message, "error");
      }

      function showSuccessMessage(message) {
        createAndShowNotification(message, "success");
      }

      function showWarningMessage(message) {
        createAndShowNotification(message, "warning");
      }

      function createAndShowNotification(message, type = "success") {
        // Remove any existing notification of the same type
        const existingNotification = document.getElementById(
          `${type}-notification`
        );
        if (existingNotification) {
          document.body.removeChild(existingNotification);
        }

        // Create new notification element
        const notification = document.createElement("div");
        notification.id = `${type}-notification`;
        notification.className = `notification notification-${type}`;

        // Create icon based on notification type
        const iconContainer = document.createElement("div");
        iconContainer.className = "notification-icon";

        let iconSvg = "";
        switch (type) {
          case "error":
            iconSvg = `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 4.5V7.5M7 9.5V9.505M13 7C13 10.3137 10.3137 13 7 13C3.68629 13 1 10.3137 1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7Z" stroke="#F24822" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`;
            break;
          case "success":
            iconSvg = `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4.5 7L6.5 9L9.5 5M13 7C13 10.3137 10.3137 13 7 13C3.68629 13 1 10.3137 1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7Z" stroke="#14AE5C" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`;
            break;
          case "warning":
            iconSvg = `<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 4.5V7.5M7 9.5V9.505M7 13C3.68629 13 1 10.3137 1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7C10.3137 13 7 13Z" stroke="#FFBD44" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`;
            break;
        }

        iconContainer.innerHTML = iconSvg;
        notification.appendChild(iconContainer);

        // Add message text
        const messageText = document.createElement("div");
        messageText.textContent = message;
        notification.appendChild(messageText);

        // Add to DOM
        document.body.appendChild(notification);

        // Trigger animation (wait a frame to ensure proper transition)
        requestAnimationFrame(() => {
          notification.classList.add("show");
        });

        // Auto-hide after 3 seconds
        setTimeout(() => {
          notification.classList.remove("show");
          // Remove from DOM after transition
          setTimeout(() => {
            if (notification.parentNode) {
              document.body.removeChild(notification);
            }
          }, 300); // Matches CSS transition time
        }, 3000);
      }

      // Ensure the active collection remains expanded until the plugin is closed
      function ensureActiveCollectionExpanded() {
        if (pluginData.activeCollectionId) {
          const activeArrow = document.querySelector(
            `.collection-${pluginData.activeCollectionId} .arrow`
          );
          const activeContent = document.querySelector(
            `.collection-content[data-collection-id="${pluginData.activeCollectionId}"]`
          );

          if (activeArrow && activeContent) {
            // Only expand if not already expanded
            if (!activeArrow.classList.contains("expanded")) {
              activeArrow.classList.add("expanded");
              activeContent.classList.add("expanded");
            }
          }
        }
      }

      // Signal to Figma that the UI is ready
      parent.postMessage({ pluginMessage: { type: "ui-ready" } }, "*");
    </script>
  </body>
</html>
